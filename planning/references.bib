@MISC{haskell_report2010,
    author = {Simon Marlow},
    title = {Haskell 2010 Language Report},
    year = {}
}

@INPROCEEDINGS{HistoryOfHaskell2007,
    author = {Paul Hudak and John Hughes and Simon Peyton Jones and Philip Wadler},
    title = {A history of Haskell: Being lazy with class},
    booktitle = {In Proceedings of the 3rd ACM SIGPLAN Conference on History of Programming Languages (HOPL-III)},
    year = {2007},
    pages = {1--55},
    publisher = {ACM Press}
}

@inproceedings{FindingTheNeedle2009,
  added-at = {2010-10-08T00:00:00.000+0200},
  author = {Allwood, Tristan O. R. and Jones, Simon L. Peyton and Eisenbach, Susan},
  biburl = {http://www.bibsonomy.org/bibtex/237642becf1c0fa5b661f8ae7e98f5024/dblp},
  booktitle = {Haskell},
  TODO______e_denna_necessary?_crossref = {conf/haskell/2009},
  editor = {Weirich, Stephanie},
  ee = {http://doi.acm.org/10.1145/1596638.1596654},
  interhash = {a2f855d51880211b220ecff83b87862e},
  intrahash = {37642becf1c0fa5b661f8ae7e98f5024},
  isbn = {978-1-60558-508-6},
  keywords = {dblp},
  pages = {129-140},
  publisher = {ACM},
  timestamp = {2010-10-08T00:00:00.000+0200},
  title = {Finding the needle: stack traces for GHC.},
  url = {http://dblp.uni-trier.de/db/conf/haskell/haskell2009.html#AllwoodJE09},
  year = 2009
}

@Article{evalapplyjfp06,
   author = {Simon Marlow and Simon {Peyton Jones}},
   title = {Making a fast curry: push/enter vs. eval/apply for higher-order languages},
   journal = {Journal of Functional Programming},
   year = {2006},
   month = {July},
   abstract = {Higher-order languages that encourage currying are typically implemented using one of
two basic evaluation models: push/enter or eval/apply.   Implementors
use their intuition and qualitative judgements
to choose one model or the other.

Our goal in this paper is to provide, for the first time, a more
substantial basis for this choice, based on our qualitative and
quantitative experience of implementing both models in a
state-of-the-art compiler for Haskell.

Our conclusion is simple, and contradicts our initial intuition:
compiled implementations should use eval/apply.
},
   url = {http://community.haskell.org/~simonmar/papers/evalapplyjfp06.pdf},
   pages = {415--449},
   volume = {16},
   number = {4--5}
}

@article{stg_1992,
    abstract = {{The Spineless Tagless G-machine is an abstract machine
      designed to support nonstrict higher-order functional languages. This
        presentation of the machine falls into three parts. Firstly, we give a
        general discussion of the design issues involved in implementing
        non-strict functional languages. Next, we present the STG language, an
        austere but recognisably-functional language, which as well as a
        denotational meaning has a well-defined operational semantics. The STG
        language is the \&quot;abstract...}},
    author = {Simon},
    citeulike-article-id = {341178},
    citeulike-linkout-0 = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729},
    journal = {Journal of Functional Programming},
    number = {2},
    pages = {127--202},
    posted-at = {2008-03-11 03:50:08},
    priority = {4},
    title = {{Implementing Lazy Functional Languages on Stock Hardware: The Spineless Tagless G-Machine}},
    url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729},
    volume = {2},
    year = {1992}
}

@ONLINE{ghc_website,
  author = {GHC Website},
  title = {What is GHC?},
  month = oct,
  year = {2013},
  url =
  {http://www.haskell.org/ghc/},
}

@ONLINE{source_transformation,
  author = {GHC Wiki},
  title = {Maintaining an explicit call stack},
  month = oct,
  year = {2013},
  url =
  {http://ghc.haskell.org/trac/ghc/wiki/ExplicitCallStack#Transformationoption1},
}

@ONLINE{haskell_in_industry,
  author = {GHC Wiki},
  title = {Haskell In Industry},
  month = oct,
  year = {2013},
  url =
  {http://www.haskell.org/haskellwiki/Haskell_in_industry},
}

@ONLINE{fpcomplete_case_studies,
  author = {FP Complete},
  title = {Case Studies},
  month = oct,
  year = {2013},
  url =
  {https://www.fpcomplete.com/business/resources/case-studies/},
}

@Comment (Nu vettefan om ONLINE verkligen parsas speciellt)@
@ONLINE{Doe,
  author = {Doe, Ringo},
  title = {This is a test entry of type {@ONLINE}},
  month = jun,
  year = {2009},
  url = {http://www.test.org/doe/}
}


@ONLINE{ghci_debugger,
  author = {GHC},
  title = {The GHCi Debugger},
  month = nov,
  year = {2013},
  url =
  {http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/ghci-debugger.html},
}

@ONLINE{oracle_java_doc_catch,
  author = {Oracle},
  title = {The catch Blocks},
  month = nov,
  year = {2013},
  url =
  {http://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html},
}

@MASTERSTHESIS{thesisFelsingBA,
  AUTHOR = {Dennis Felsing},
  TITLE = {Visualization of Lazy Evaluation and Sharing},
  SCHOOL = {Karlsruhe Institute of Technology},
  TYPE = {Bachelor's Thesis},
  ADDRESS = {Germany},
  MONTH = SEP,
  YEAR = 2012,
  PDF = {http://felsin9.de/nnis/ghc-vis/thesis/thesis.pdf}
}

@inproceedings{mitchell:catch_2008_9_25,
     title          = {Not All Patterns, But Enough - an automatic verifier for partial but sufficient pattern matching}
    ,author         = {Neil Mitchell and Colin Runciman}
    ,year           = {2008}
    ,month          = {September}
    ,day            = {25}
    ,booktitle      = {Haskell '08: Proceedings of the first ACM SIGPLAN symposium on Haskell}
    ,pages          = {49--60}
    ,location       = {Victoria, BC, Canada}
    ,doi            = {http://doi.acm.org/10.1145/1411286.1411293}
    ,publisher      = {ACM}
    ,isbn           = {978-1-60558-064-7}
    ,url            = {http://community.haskell.org/~ndm/downloads/paper-not_all_patterns_but_enough-25_sep_2008.pdf}
}

@TODO{hat_website,
  url = http://projects.haskell.org/hat/
}

@Comment (9th oct 2013)
@TODO{ghc_wiki_explicitcs_transformation,
  url = http://ghc.haskell.org/trac/ghc/wiki/ExplicitCallStack\#Transformationoption1
}


@TODO{clements_dissertation2005,
  title = {Portable and high-level access to the stack with Continuation Marks},
  author = {John Clements},
  url = http://www.brinckerhoff.org/clements/papers/index.html
  
}

@inproceedings{ckl2004,
  AUTHOR    = { Clarke, Edmund
                and Kroening, Daniel
                and Lerda, Flavio },
  TITLE     = { A Tool for Checking {ANSI-C} Programs },
  BOOKTITLE = { Tools and Algorithms for the Construction and Analysis of Systems (TACAS 2004) },
  YEAR      = { 2004 },
  PUBLISHER = { Springer },
  PAGES     = { 168--176 },
  ISBN      = { 3-540-21299-X },
  SERIES    = { Lecture Notes in Computer Science },
  VOLUME    = { 2988 },
  EDITOR    = { Kurt Jensen and Andreas Podelski },
}

@article{dantam2013motion,
  title = {The Motion Grammar: Analysis of a Linguistic Method for Robot Control},
  number = {3},
  volume = {29},
  pages = {704--718},
  journal = {IEEE/RAS Transactions on Robotics},
  author = {Neil T. Dantam and Mike Stilman},
  year = {2013}
}
