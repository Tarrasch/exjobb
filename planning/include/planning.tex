% Mostly for planning report
\chapter{Objective, Scope, Method and Time-plan}

This work will only examine stack trace retrieval using the execution stack. In
contrast to doing transformations of code so that an explicit call stack is
passed along function calls. Such transformations  can happen at either source
level (see ghc-wiki-link) or at an intermediate representation level, like the GHC
CORE (see: finiding the needle).

By not explicitly passing around a stack between function calls, run-time
performance will not be affected in our implementation. The drawback, however,
is that we will no longer print the exact stack we want. Ideally the printed
stack should only contain references to functions from Haskell source code. But
the execution stack is containing frames from the Spineless Tagless G-Machine
(source? really, im unsure.).  This has the unfortunate effect that the stack
trace will contain functions that are not related to the language Haskell but
the specific implementation of GHC. After all, the concept of having an
execution stack is coupled to a particular way of implementing haskell.
(source?)  A stack trace of the execution of a program (Reference to program)
could look like this:

<bild/tabell pÃ¥ kass stack trace>

This motivates the final planned step for this thesis work. To try to yet
improve the printed stack trace. Again, an ideal stack should only show
functions from real haskell source code.  One idea would be to allow the
compiled program to take a small amount of performance penalty by slightly
changing the execution stack. Another idea is to be smarter when getting the
series of stack frames, should we just print out each frame or should we base
our actions and change policy based on the contents of the various frame kinds?
The STG-machine have frames for thunk updates (source?) and the profiler have
frames for cost centres (source? E ju bara att testa egentligen).

\section{Method}

I've found it reasonable to split the work into two milestones.

\subsection{Milestone: Retrieving the execution stack}

I should implement a complete implementation of stack trace printing in GHCs
runtime system. I should merge this into the HEAD of the ghc project, meaning
that a sizeable amount of documentation must be accompanied with the patches.
Further, I should analyze to see that this implementation does not slow down
compiled programs or have any memory footprint. I should also measure how much
blowup the binary size suffers and how much slower compilation gets. It would
also be useful to stress test my implementation to verify that there are no
bugs, and to make sure the implementation only works when the garbage collector
doesn't kick in. Stack traces should also be available in haskell-land when this
milestone is over.

% TODO Fixa meningsstrukturen utan massa "I should" etc.

\subsection{Milestone: Changing the execution stack OR Treating it wisely}

Ultimately we want useful stack traces that help us find that annoying bug.
Clearly good stack traces are useful and a dump of the execution stack like in
figure (FYLL I) is not as helpful as the one in figure (FYLL I). The previous
paragraphs speculated on two get a stack that's more user-friendly. Due to
formulations like "a better stack" or "a more user-friendly stack", it will be
partially subjective to decide when this milestone is reached. Though there are
some clear tasks too. For example, the approach of changing the execution stack
is expected to degrade the run-time performance in both speed and memory. This
should all be measured and documented. Since there is no guarantee that I will
find a efficient way to get a nice stack from the execution stack, I'm not
confident if it'll ever reach a state worth merging into ghc HEAD. And to limit
the scope of this thesis work, I don't plan to merging my work from this
milestone, regardless of it's outcome.

It should be noted that this second milestone will be the part that explores the
most general question formulation in my thesis. Namely how to turn a execution
stack of a lazy functional language implemented with a stg-machine into
something user-friendly.

\section{Time-plan}

I've found the two milestones to be roughly similar in size. At the time of
writing we're at the end of October 2013. By the end of December 2013 I hope to
be done with the first milestone and by the end of February 2014 I hope to be
done with the second. Now I do expect to start working on the second milestone
before the first one finishes, in particular because that merging patches to a
open source project as big as GHC will require some iterations. In addition, the
patches will rely on the dwarf profiling patches that are currently pending at
the time of writing (source?).

\subsection{Listening to oral presentations and Opposition}

By applying the recommendations of the CSE instituation at Chalmers. I should
listen to to oral presentations in December and oppose in January.

\subsection{Final written report and oral presentation}

I'll dedicate March 2014 to submitting my final written report and doing my oral
presentation.

