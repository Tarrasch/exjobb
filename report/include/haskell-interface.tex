\chapter{A Haskell Interface}

Our goal is for Haskell to "have stack traces". So far we've been
very vague in our goal. We \emph{could} ask ourselves: Do we want a
full-blown Haskell API or just to be able to print the stack trace on
crashes? % TODO: Crash 채r fel ord. Typ hellre n책got med "uncaught exception"
But it turns out that just phrasing this question is hard.
It might sound reasonable to say that the most rudimentary feature
would be that whenever the program crashes, a stack trace should be
printed. Features like Haskell-land access to the stack would then
be an extension. But this doesn't make sense from an implementation
perspective, it is much easier to write a Haskell-wrapper for examining
the current execution stack than doing an efficient reification at the
crash site, recall how the whole of section \ref{sec:lazy_reification}
was dedicated to this. Regardless of a Haskell wrapper being technically
easy to do,
the troubles of making it user-friendly are 
raised in section 6.1 TODO. In section
6.2 TODO we look at how the exception system in Haskell is now and
in section 6.3 TODO we look at ways to fit in a stack value into the
exception system without affecting existing code too much and still
being convenient to use.

% Alternativt s책 mergar jag dem tv책 sista sektionerna! TODO ?

\section{The \texttt{ExecutionStack} type}

The stack traces shown as of yet look something like this:

\begin{minted}[gobble=2]{text}
  3: showSignedInt
  4: print
  5: writeBlocks
\end{minted}

We have basically assumed that the DWARF debug data gives us a simple
mapping like:

\begin{minted}[gobble=2]{haskell}
  import Foreign.Ptr (Ptr)

  data Instruction -- Empty data declaration (for type safety)
  type FunctionName = String

  lookupWithDwarf :: Ptr Instruction -> IO FunctionName
\end{minted}

This simple model matches how stack traces has been presented as of
yet. But we actually get much more information than just the function name
from the DWARF info. We also know in which file it was defined and more
exactly where in the function. A stack trace including all this
information could look like this:

\begin{minted}[gobble=2]{text}
  3: showSignedInt (at libraries/base/GHC/Show.lhs:432:1-434:56)
  4: print (at libraries/base/System/IO.hs:281:29-281:37)
  5: writeBlocks (at libraries/base/GHC/IO/Handle/Text.hs:584:4-609:31)
\end{minted}

We have created a Haskell data type to encapsulate one frame like shown
above. We call the data type a \texttt{LocationInfo} and its definition
is in figure \ref{fig:location_info}.

\begin{figure}
\begin{mdframed}
  \begin{minted}[gobble=4]{haskell}
    -- | Location in source code.
    data LocationInfo = LocationInfo
        { startLine    :: !Word16
        , startCol     :: !Word16
        , endLine      :: !Word16
        , endCol       :: !Word16
        , fileName     :: !String
        , functionName :: !String
        }
        deriving(Eq)
  \end{minted}
  \caption{The information necessary to display a \emph{row} from the stack
    trace.}
  \label{fig:location_info}
\end{mdframed}
\end{figure}

Yet, there is even more information stored in the DWARF data. For a
given instruction pointer, you would usually associate it to only one
place in the source code, but the situation is not always clear cut due
to code transformations like inlining. Instead we that we have a
mapping from one instruction pointer to \emph{many} source functions.

\begin{minted}[gobble=2]{text}
  3: showSignedInt (at libraries/base/GHC/Show.lhs:432:1-434:56)
  4: print (at libraries/base/System/IO.hs:281:29-281:37)
     putStrLn (at libraries/base/System/IO.hs:267:37-267:38)
     print (at libraries/base/System/IO.hs:281:35-281:36)
  5: writeBlocks (at libraries/base/GHC/IO/Handle/Text.hs:584:4-609:31)
\end{minted}

With the fact that each instruction pointer maps to multiple
source locations, it would make sense for \texttt{lookupWithDwarf} to
return a list of \texttt{LocationInfo}s.
Perhaps the signature should be like the following?

\begin{minted}[gobble=2]{haskell}
  lookupWithDwarf :: Ptr Instruction -> IO [LocationInfo]
\end{minted}

Unfortunately, dwarf information is not always available in the
executable, for example if a Haskell module have been compiled without
the
\texttt{-g} flag. Luckily, symbol table information might still be
packaged inside the binary, which would be able to get out some useful
information.

Note that only \emph{some} modules might have been compiled
with or without \texttt{-g}, so a stack trace could have some stack frames actually
resolved while others just contain information extracted from the symbol
table. Here is an excerpt of a stack trace where the Haskell module \texttt{GHC.Show}
was compiled without the \texttt{-g} flag.

\begin{minted}[gobble=2]{text}
  3: c1lo_entry (using libraries/base/GHC/Show.lhs)
  4: print (at libraries/base/System/IO.hs:281:29-281:37)
     putStrLn (at libraries/base/System/IO.hs:267:37-267:38)
     print (at libraries/base/System/IO.hs:281:35-281:36)
  5: writeBlocks (at libraries/base/GHC/IO/Handle/Text.hs:584:4-609:31)
\end{minted}

While \texttt{c1lo\_entry} is not too useful (but it it hints that it
could be a case continuation), the second piece of information is
useful. The file \texttt{Show.lhs} would probably have something to do
with converting a value to a string. Therefore, it would help if the
Haskell value includes this information when it is present. With this
in mind, we decide on the API shown in figure \ref{fig:lookup_with_dwarf}
and \ref{fig:stack_frame}.

\begin{figure}
\begin{mdframed}
  \begin{minted}[gobble=4]{haskell}
    lookupWithDwarf :: Ptr Instruction -> IO StackFrame
  \end{minted}
  \caption{Given an instruction pointer, you get a \texttt{StackFrame} value.}
  \label{fig:lookup_with_dwarf}
\end{mdframed}
\end{figure}

\begin{figure}
\begin{mdframed}
  \begin{minted}[gobble=4]{haskell}
    data StackFrame = StackFrame
        { unitName      :: !String -- From symbol table
        , procedureName :: !String -- Also from symbol table
        , locationInfos :: ![LocationInfo] -- Empty without -g flag to ghc
        }
  \end{minted}
  \caption{The information necessary to display a \emph{frame} from the stack
    trace.}
  \label{fig:stack_frame}
\end{mdframed}
\end{figure}

These decisions are debatable. What happens if there is no symbol
table? What happens if the frame on the execution stack was an update
frame, but we reified the code pointer of its payload (recall section
\ref{sec:update_frames})? Both the signature

\begin{minted}[gobble=2]{haskell}
  lookupWithDwarf :: Ptr Instruction -> IO (Maybe StackFrame)
\end{minted}

and

\begin{minted}[gobble=2]{haskell}
  lookupWithDwarf :: Ptr Instruction -> IO [StackFrame]
\end{minted}

makes sense. But the API should preferably be simple and natural. Most
programmers might be used to a one to one mapping between instruction pointer
and source code. Therefore we choose the signature in figure
\ref{fig:lookup_with_dwarf}. Then, when the programmer looks at what a
\texttt{StackFrame} is, \emph{then} they will be gently introduced to
the fact that a stack frame may contain multiple \texttt{LocationInfo}s.
Contrast this to giving an API based on these observations:

\begin{itemize}
  \item
    One execution stack frame maps to multiple stack frames (like for
    update frames).
  \item
    We "meld" \texttt{StackFrame} and \texttt{LocationInfo}s, basically
    substituting \texttt{StackFrame} with \texttt{[LocationInfo]}.
  \item
    We have function \texttt{getStackFrames} that return a list of the
    frames on the execution stack.
\end{itemize}

Then we would end up with a function like:

\begin{minted}[gobble=2]{haskell}
  getStackFrames :: IO [[[Locationinfo]]]
\end{minted}

Or if we commented the signature:

\begin{minted}[gobble=2]{haskell}
  getStackFrames :: IO
    [ -- The execution stack has multiple frames
     [ -- Each execution stack frame maps to multiple frames
      [ -- An instruction pointer maps to multiple source code locations
      Locationinfo
      ]
     ]
    ]
\end{minted}

No, this is not a user-friendly API. Still, we need to discuss the issue
that the symbol table could have been stripped away and that update
frames can be thought of multiple frames. We solve the first issue by
simply setting the \texttt{String}-fields of a \texttt{StackFrame} to
a descriptive value like \texttt{"<No data>"} if we do not find anything
in the symbol table. In the case of having an
execution stack frame that corresponds to multiple
frames (like for update frames), we pick the most helpful stack frame
(the updatee over the updater).
After all, most reification methods from the previous chapter is only
capable of storing one info pointer per stack frame. But if we were
making all frames accessible from the Haskell API, one idea would be
to squeeze in another field \texttt{next :: Maybe StackFrame} in the
definition of \texttt{StackFrame} from figure \ref{fig:stack_frame}.
Then that particular field's documentation could explain how it works.

Lastly, the API will include some non-controversial functions like
pretty-printing of the execution stack.  Since there is only one natural
implementation for these functions, we do not discuss them further.

\section{Exception system in Haskell}

blah, this is how it already is.

\section{Adding the stack to exceptions}

blah
