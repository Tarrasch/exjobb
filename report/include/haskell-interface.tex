\chapter{A Haskell Interface}

Our goal is for Haskell to "have stack traces". This could just mean
that the language prints a stack trace when the program crashes, however
it would be more powerful if the programmer has some control of this.
With an Haskell-API, the programmer can print the stack trace at
will and not only on crashes. Further, the programmer could examine
what is on the stack, for example one could check
if the function \texttt{foo} is on the stack or not. For this to be
possible, some interface has to exist in Haskell-land. One contribution
of this thesis is a Haskell API to the execution stack, section
\ref{sec:user-invoked_reification} explains the design choices when
creating that interface. Aside from the API, it would also be great if
stack traces got integrated into the exception system, since once
an exception has occurred, it is to late to get the original stack
trace, somehow the stack trace has to be passed to the exception
handler. This will be discussed
in section \ref{sec:adding_the_trace}. Section \ref{sec:exception_system} covers the
preliminaries needed to understand section \ref{sec:adding_the_trace}.


% So far we've been
% very vague in our goal. We \emph{could} ask ourselves: Do we want a
% full-blown Haskell API or just to be able to print the stack trace on
% crashes? % TODO: Crash 채r fel ord. Typ hellre n책got med "uncaught exception"
% But it turns out that just phrasing this question is hard.
% It might sound reasonable to say that the most rudimentary feature
% would be that whenever the program crashes, a stack trace should be
% printed. Features like Haskell-land access to the stack would then
% be an extension. But this doesn't make sense from an implementation
% perspective, it is much easier to write a Haskell-wrapper for examining
% the current execution stack than doing an efficient reification at the
% crash site, recall how the whole of section \ref{sec:lazy_reification}
% was dedicated to this. Regardless of a Haskell wrapper being technically
% easy to do,
% the troubles of making it user-friendly are
% raised in section 6.1 TODO. In section
% 6.2 TODO we look at how the exception system in Haskell is now and
% in section 6.3 TODO we look at ways to fit in a stack value into the
% exception system without affecting existing code too much and still
% being convenient to use.

% Alternativt s책 mergar jag dem tv책 sista sektionerna! TODO ?

\section{User-invoked reification} \label{sec:user-invoked_reification}

The stack traces shown in section \ref{sec:frames_of_interest} look
something like this:

\begin{minted}[gobble=2]{text}
  3: showSignedInt
  4: print
  5: writeBlocks
\end{minted}

We basically have assumed that the DWARF debug data gives us a simple
mapping from instruction pointer to function names. We could model
this in Haskell:

\begin{minted}[gobble=2]{haskell}
  import Foreign.Ptr (Ptr)

  data Instruction -- Empty data declaration (for type safety)
  type FunctionName = String

  lookupWithDwarf :: Ptr Instruction -> IO FunctionName
\end{minted}

But we actually get much more information than just the function name
from the DWARF info. We also know in which file it was defined and more
exactly where in the function. A stack trace including all this
information could look like this:

\begin{minted}[gobble=2]{text}
  3: showSignedInt (at libraries/base/GHC/Show.lhs:432:1-434:56)
  4: print (at libraries/base/System/IO.hs:281:29-281:37)
  5: writeBlocks (at libraries/base/GHC/IO/Handle/Text.hs:584:4-609:31)
\end{minted}

We have created a Haskell data type to encapsulate one frame like shown
above. We call the data type a \texttt{LocationInfo} and its definition
is in figure \ref{fig:location_info}.

\begin{figure}
\begin{mdframed}
  \begin{minted}[gobble=4]{haskell}
    -- | Location in source code.
    data LocationInfo = LocationInfo
        { startLine    :: !Word16
        , startCol     :: !Word16
        , endLine      :: !Word16
        , endCol       :: !Word16
        , fileName     :: !String
        , functionName :: !String
        }
        deriving(Eq)
  \end{minted}
  \caption{The information necessary to display a \emph{row} from the stack
    trace.}
  \label{fig:location_info}
\end{mdframed}
\end{figure}

Yet, there is even more information stored in the DWARF data. For a
given instruction pointer, you would usually associate it to only one
place in the source code, but the situation is not always clear cut due
to code transformations like inlining. Instead we that we have a
mapping from one instruction pointer to \emph{many} source functions.

\begin{minted}[gobble=2]{text}
  3: showSignedInt (at libraries/base/GHC/Show.lhs:432:1-434:56)
  4: print (at libraries/base/System/IO.hs:281:29-281:37)
     putStrLn (at libraries/base/System/IO.hs:267:37-267:38)
     print (at libraries/base/System/IO.hs:281:35-281:36)
  5: writeBlocks (at libraries/base/GHC/IO/Handle/Text.hs:584:4-609:31)
\end{minted}

With the fact that each instruction pointer maps to multiple
source locations, it would make sense for \texttt{lookupWithDwarf} to
return a list of \texttt{LocationInfo}s.
Perhaps the signature should be like the following?

\begin{minted}[gobble=2]{haskell}
  lookupWithDwarf :: Ptr Instruction -> IO [LocationInfo]
\end{minted}

Unfortunately, dwarf information is not always available in the
executable, for example if a Haskell module have been compiled without
the
\texttt{-g} flag. Luckily, symbol table information might still be
packaged inside the binary, which would be able to get out some useful
information.

Note that only \emph{some} modules might have been compiled
with or without \texttt{-g}, so a stack trace could have some stack frames actually
resolved while others just contain information extracted from the symbol
table. Here is an excerpt of a stack trace where the Haskell module \texttt{GHC.Show}
was compiled without the \texttt{-g} flag.

\begin{minted}[gobble=2]{text}
  3: c1lo_entry (using libraries/base/GHC/Show.lhs)
  4: print (at libraries/base/System/IO.hs:281:29-281:37)
     putStrLn (at libraries/base/System/IO.hs:267:37-267:38)
     print (at libraries/base/System/IO.hs:281:35-281:36)
  5: writeBlocks (at libraries/base/GHC/IO/Handle/Text.hs:584:4-609:31)
\end{minted}

While \texttt{c1lo\_entry} is not too useful (but it hints that it
could be a case continuation), the second piece of information is
useful. The file \texttt{Show.lhs} would probably have something to do
with converting a value to a string. Therefore, it would help if the
Haskell value includes this information when it is present. With this
in mind, we decide on the API shown in figure \ref{fig:lookup_with_dwarf}
and \ref{fig:stack_frame}.

\begin{figure}
\begin{mdframed}
  \begin{minted}[gobble=4]{haskell}
    lookupWithDwarf :: Ptr Instruction -> IO StackFrame
  \end{minted}
  \caption{Given an instruction pointer, you get a \texttt{StackFrame} value.}
  \label{fig:lookup_with_dwarf}
\end{mdframed}
\end{figure}

\begin{figure}
\begin{mdframed}
  \begin{minted}[gobble=4]{haskell}
    data StackFrame = StackFrame
        { unitName      :: !String -- From symbol table
        , procedureName :: !String -- Also from symbol table
        , locationInfos :: ![LocationInfo] -- Empty without -g flag to ghc
        }
  \end{minted}
  \caption{The information necessary to display a \emph{frame} from the stack
    trace.}
  \label{fig:stack_frame}
\end{mdframed}
\end{figure}

These decisions are debatable. What happens if there is no symbol
table? What happens if the frame on the execution stack was an update
frame, but we reified the code pointer of its payload (recall section
\ref{sec:update_frames})? Both the signature

\begin{minted}[gobble=2]{haskell}
  lookupWithDwarf :: Ptr Instruction -> IO (Maybe StackFrame)
\end{minted}

and

\begin{minted}[gobble=2]{haskell}
  lookupWithDwarf :: Ptr Instruction -> IO [StackFrame]
\end{minted}

makes sense. But the API should preferably be simple and natural. Most
programmers might be used to a one to one mapping between instruction pointer
and source code. Therefore we choose the signature in figure
\ref{fig:lookup_with_dwarf}. Then, when the programmer looks at what a
\texttt{StackFrame} is, \emph{then} they will be gently introduced to
the fact that a stack frame may contain multiple \texttt{LocationInfo}s.
Contrast this to giving an API based on these observations:

\begin{itemize}
  \item
    One execution stack frame maps to multiple stack frames (like for
    update frames).
  \item
    We "meld" \texttt{StackFrame} and \texttt{LocationInfo}s, basically
    substituting \texttt{StackFrame} with \texttt{[LocationInfo]}.
  \item
    We have function \texttt{getStackFrames} that return a list of the
    frames on the execution stack.
\end{itemize}

Then we would end up with a function like:

\begin{minted}[gobble=2]{haskell}
  getStackFrames :: IO [[[Locationinfo]]]
\end{minted}

Or if we commented the signature:

\begin{minted}[gobble=2]{haskell}
  getStackFrames :: IO
    [ -- The execution stack has multiple frames
     [ -- Each execution stack frame maps to multiple frames
      [ -- An instruction pointer maps to multiple source code locations
      Locationinfo
      ]
     ]
    ]
\end{minted}

No, this is not a user-friendly API. Still, we need to discuss the issue
that the symbol table could have been stripped away and that update
frames can be thought of multiple frames. We solve the first issue by
simply setting the \texttt{String}-fields of a \texttt{StackFrame} to
a descriptive value like \texttt{"<No data>"} if we do not find anything
in the symbol table. In the case of having an
execution stack frame that corresponds to multiple
frames (like for update frames), we pick the most helpful stack frame
(the updatee over the updater).
After all, most reification methods from the previous chapter is only
capable of storing one info pointer per stack frame. But if we were
making all frames accessible from the Haskell API, one idea would be
to squeeze in another field \texttt{next :: Maybe StackFrame} in the
definition of \texttt{StackFrame} from figure \ref{fig:stack_frame}.
Then that particular field's documentation could explain how it works.

Lastly, the API will include some non-controversial functions like
pretty-printing of the execution stack.  Since there is only one natural
implementation for these functions, we do not discuss them further.

\section{Exception system} \label{sec:exception_system}

The \emph{exception system} of a language is how throwing and catching
is done in that language. The exception system for GHC got an
overhaul when version \texttt{6.10.1} was released in November 2008
\cite{haskell_org_release_6.10.1}. The design of the new exception
system was introduced in a paper from 2006 \cite{marlow2006extensible}.
In this section we will look at how this relatively new and current
exception system works. The most recent Haskell report does not mention
this exception system \cite[ch. 42]{haskell_report2010}, but we only
care about GHC here and still consider ``Haskell'' to mean the language
implemented in GHC.

The exception system in Haskell is surprisingly similar to
Java's.  There is a root exception type in Java called \texttt{Exception}
and the Haskell equivalent is called \texttt{SomeException}. One
subclass of exceptions are arithmetic exceptions, Java has
\texttt{ArithmeticException} and Haskell has \texttt{ArithException}.
So Java and Haskell are similar in the sense that they both have an
\emph{extensible and hierarchical} exception system.  Haskell, unlike
Java, do not have anything like the \texttt{throws}
annotation\footnote{Introduced in section
\ref{sec:error_handling_in_haskell}.}
in the type system, but it can be implemented as a library
\cite{github_pepeiborra_cme, hackage_control_monad_exception}.

One way to learn the Haskell exception system is to study the
documentation of the \texttt{Control.Exception} module from the
\texttt{base} library \cite{hackage_base_control_exception}.
That module is quite sizeable, so
we will only study the \texttt{catch} and \texttt{throw} functions since
that is enough background to be able to discuss how stack traces can be added
to the exception system. The documentation contains many functions with various best practices
the programmer should know, \texttt{catch} and
\texttt{throw} is not enough to write good code. With
these warnings being pronounced we go on and with some example
uses of \texttt{catch} and \texttt{throw}. Let's fire up GHCi.

\begin{minted}[gobble=2]{haskell}
  -- We import what we need
  > :set -XScopedTypeVariables
  > import Control.Exception

  -- It is equivalent to cause the exception and to throw it manually
  > (1 `div` 0)
  *** Exception: divide by zero
  > throw DivideByZero
  *** Exception: divide by zero

  -- You can catch the exception
  > catch (throw DivideByZero) (\ (e :: SomeException) -> putStrLn "Yaay")
  Yaay

  -- But if the type of the error you are catching is not a superclass
  -- of the exception being thrown, the catch will not be caught
  > catch (throw DivideByZero) (\ (e :: IOException ) -> putStrLn "Yaay")
  *** Exception: divide by zero
\end{minted}

The type signatures of \texttt{catch} and \texttt{throw} can be found in
figure \ref{fig:catch_and_throw}. The signatures are reproduced from the
documentation \cite{hackage_base_control_exception}. The type signature
for both functions are in the form \texttt{:: Exception e => ...}, this
means that \texttt{e} is a constrained type. The type variable
\texttt{e} can not be of any type, for example it can not be an \texttt{Int} or a
\texttt{String}, it has to be some sort of an \texttt{Exception}.
\texttt{Exception} is not a type (unlike \texttt{SomeException} and
\texttt{ArithException}), \texttt{Exception} is
\emph{type class}\footnote{The name ``class'' is unfortunate since
it is not at all like classes in object oriented programming, it is
more like interfaces.}! For a particular type to qualify as being an
\texttt{Exception} type, it must adhere to the following interface:

\begin{figure}
\begin{mdframed}
  \begin{minted}[gobble=4]{haskell}
    -- | Throw an exception.  Exceptions may be thrown from purely
    -- functional code, but may only be caught within the 'IO' monad.
    throw :: Exception e => e -> a

    -- | This is the simplest of the exception-catching functions. It
    -- takes a single argument, runs it, and if an exception is raised
    -- the "handler" is executed, with the value of the exception passed
    -- as an argument. Otherwise, the result is returned as normal.
    catch   :: Exception e
            => IO a         -- The computation to run
            -> (e -> IO a)  -- Handler to invoke if an exception is raised
            -> IO a
  \end{minted}
  \caption{The function signatures for \texttt{catch} and
    \texttt{throw} and some excerpts of the documentation.}
  \label{fig:catch_and_throw}
\end{mdframed}
\end{figure}

\begin{itemize}
  \item
    Any value of type \texttt{e} can be converted
    into a value of type \texttt{SomeException}. The programmer has to
    provide the function:
    \mint{haskell}|toException :: e -> SomeException|
  \item
    All \texttt{SomeException} values must have a more concrete type
    underneath\footnote{At least all total and finite
      \texttt{SomeException} values}, the concrete type could for
    example be an \texttt{ArithException}. In general we
    would ask ourselves if a particular \texttt{SomeException} value is
    somewhere down the hierarchy built using a node of type \texttt{e}.
    If so, we say that we can \emph{downcast} a
    \texttt{SomeException}-value to a value of type \texttt{e},
    essentially we are looking for a downcasting function in Haskell.
    This will probably be achieved using dynamic types in Haskell.
    To fulfill the \texttt{Exception} interface 
    the programmer has to provide the following downcasting-like
    function:
    \mint{haskell}|fromException :: SomeException -> Maybe e|
\end{itemize}

So as indicated from the type signatures of \texttt{throw}
and \texttt{catch}, they do use the \texttt{toException} and
\texttt{fromException} functions (otherwise they would not need the
type class constraint). The implementation of \texttt{throw} use
\texttt{toException} and \texttt{catch} uses \texttt{fromException} can
be used on it \cite{github_catch_uses_SomeException}.

The implementation of \texttt{toException} and \texttt{fromException}
differs for every type. But the convention is that \texttt{toException}
wraps a bare exception value into wrappers, one wrapper per level of
hierarchy. Similarly \texttt{fromException} removes the layers. For the
hierarchy shown in figure \ref{fig:exception_hierarchy}, the
\texttt{toException} and \texttt{fromException} functions would work
like this:

\begin{figure}
\begin{mdframed}
  \includegraphics[width=5in]{build/fig/exception_hierarchy}
  \caption{One example exception hierarchy.}
  \label{fig:exception_hierarchy}
\end{mdframed}
\end{figure}

\begin{minted}[gobble=2, samepage=true]{haskell}
  > toException MismatchedParentheses
  SomeException
    (SomeCompilerException
      (SomeFrontendException MismatchedParentheses))

  > toException TypeCheckerFailure
  SomeException
    (SomeCompilerException
      (SomeFrontendException TypeCheckerFailure))

  > (fromException :: SomeException -> MismatchedParentheses)
      (toException MismatchedParentheses)
  (Just MismatchedParentheses)

  > (fromException :: SomeException -> TypeCheckerFailure)
      (toException MismatchedParentheses)
  Nothing
\end{minted}

The multiple layer of constructors is added by \texttt{toException}
and \texttt{fromException} checks if its argument was wrapped by the
corresponding \texttt{toException} function. When seeing this it should
be clear that we are not really doing downcasting in the OOP sense. When using
\texttt{fromException} we are actually loosing information, we
can not upcast the value back to its \emph{original} value of type
\texttt{SomeException}. Contrast this to the real downcasting that is
done in Java, when an \texttt{Exception} in Java is successfully
downcasted to a \texttt{ArithmeticException} value it is still the same
value, only with a new type. Upcasting is always possible in Java by
doing a normal type cast.






\section{Adding the trace} \label{sec:adding_the_trace}

In this section we will look at two problems. First, how can we give
the handler a stack value? Second, which stack should be reified
when we throw inside the handler? When answering these questions, we
say that we have a type called \texttt{ExecutionStack}, values of
this type will be named \texttt{executionStack} by convention. The
underlying implementation and data representation will depend on what
implementation from section \ref{sec:lazy_reification} we use. This section
deals with how the \texttt{ExecutionStack} value should be passed around
when exceptions are thrown.

\subsection{Catching the stack}

To catch the stack should have an intuitive interface. Possibly
something like
\mint{haskell}|catchWithStack :: Exception e => IO a -> Handler e -> IO a|
Where \texttt{Handler e} is either \texttt{(e -> ExecutionStack -> IO a)} or
\texttt{(e -> Maybe ExecutionStack -> IO a)}. Another approach would be
if there was a function like
\mint{haskell}|getStack :: Exception e => e -> ExecutionStack|
This would be \emph{very} convenient and would solve both catching and
throwing at the same time. It is now time to look at possible
implementations
that would give a decent Haskell-interface to the programmer.

\subsubsection{Implementations in pure Haskell}

We can change the type of \texttt{SomeException} from

\begin{minted}[gobble=2, samepage=true]{haskell}
  data SomeException =
    forall e . Exception e => SomeException e
\end{minted}

to

\begin{minted}[gobble=2, samepage=true]{haskell}
  data SomeException =
    forall e . Exception e => SomeException e ExecutionStack
\end{minted}

% TODO: Vafan blir formateringen CP h채r f철r? SomeException t채nker jag p책
But this would break backwards compatibility because you change the type
of \texttt{SomeException}. Furthermore it is not as convenient as it
seems. If the programmer catches an exception downcasted to say an
\texttt{ArithException}, it would be intuitive that the stack trace
would be reused if you throw the exception variable because the stack
trace is stored in the exception value. But that is not true once you
downcast the \texttt{SomeException}. This is particularly confusing for
programmers used to Java, where the downcast is actually a downcast and
not a series of unwrappings loosing information for each unwrapping.

Another similar design is to add an \emph{optional} layer containing
the stack. If \texttt{(toException DivideByZero)} evaluates to
\texttt{(SomeException DivideByZero)}, we could imagine a function
\texttt{toExceptionWithStack} where \texttt{(toExceptionWithStack
DivideByZero)} evaluates to \texttt{(SomeException (WithStack
DivideByZero executionStack))}. While this does not break backwards
compatibility, users has to actively choose
\texttt{toExceptionWithStack} over \texttt{toException}. Ideally
everything should work automatically without changing all the exception
related code in all libraries. This solution also suffers from the
problems with downcasting.

\subsubsection{RTS-based solutions}

It would be desirable for our solution to be implemented as much
as possible in a Haskell library instead of the run time system, it
would then work for any Haskell compiler and not only GHC. But since we
did not find anything fully satisfactory when limiting ourselves to
solutions in Haskell-land, we will now broaden the solution space to
include RTS changes.

Currently, control is passed to the run time system when an
exception is thrown. The RTS gets passed control when functions like
\texttt{throw}\cite{hackage_base_control_exception_throw} and \texttt{error}
are invoked, because both will eventually call \texttt{raise\#} which is
written in Cmm\cite{github_raisezh}. When \texttt{raise\#} is called, it
will walk the stack towards the first frame type that (possibly) can
handle exceptions (but we only consider \texttt{CATCH\_FRAME})
\cite{github_raisezh_calls_helper, github_raiseExceptionHelter}.
When a \texttt{CATCH\_FRAME} frame is found, \texttt{raise\#} will
run the frame's handler with the exception passed as an argument. The
handler on the stack should therefore be of arity 1, more precisely
it should confirm to \texttt{(Exception e => e -> IO a)}. The way to get
this catch frame on the stack in the first place is to use the primitive
\texttt{catch\#}, for example it could be invoked with \texttt{(catch\#
  ioThatCanCrash myHandler)}. GHC allows even primitive functions to
have type signatures, this is an extra sanity check for GHC maintainers.
The type signature for \texttt{catch\#} is:
\mint{haskell}|catch# :: IO a -> (exception -> IO a) -> IO a|
Note how the type system for primitives is weaker, we can not constrain
the type variable \texttt{exception} to belong to the type class \texttt{Exception}.

There are many interesting possibilities here, for example in Peter
Wortmann's demonstration from section \ref{sec:recent_work} he changed the
\texttt{catch\#} primitive to have the following signature:
\mint{haskell}|catch# :: IO a -> (exception -> ByteArray#-> IO a) -> IO a|
Where \texttt{ByteArray\#} contains the reified stack. With this change
it would be trivial to implement \texttt{catchWithStack} and
to reimplement \texttt{catch} in terms of \texttt{catchWithStack}. But
also the \texttt{raise\#} primitive must change its implementation. After
all \texttt{raise\#} is the function that invokes the handler
(\texttt{catch\#} just pushes it on the stack). But where could
\texttt{raise\#} get the original stack from? It actually can \emph{start} by
reifying the stack, saving it in a local variable and \emph{then} look
for the \texttt{CATCH\_FRAME} frame. When the catch frame is found it
can run the handler with both the exception and the reified stack.

Another approach would be to not change the signature of
\texttt{catch\#}. But how would \texttt{catchWithStack} be implemented if
the undermost handler does not take the execution stack as an argument?
Of course it could be put in the exception value, but we propose to
instead push a \emph{recovery frame}, the recovery frame would contain
the stack value. Figure \ref{fig:recovery_frame} illustrates when and
where a recovery frame would be pushed. Once the handler
gets control, we know that stack pointer \texttt{Sp} points
at the recovery frame. It would then be a constant time operation to
retrieve the stack value. We can imagine a function with this
signature:

\begin{figure}
\begin{mdframed}
  \begin{subfigure}[t]{0.5\textwidth}
    \includegraphics[width=2.8in]{build/fig/catch_frame}
    \caption{The stack when \texttt{raise\#} is invoked.}
  \end{subfigure}
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
          %(or a blank line to force the subfigure onto a new line)
  \begin{subfigure}[t]{0.5\textwidth}
    \includegraphics[width=2.8in]{build/fig/recovery_frame}
    \caption{The stack when the handler is invoked.}
  \end{subfigure}
  \caption{The stack before and after an exception}
  \label{fig:recovery_frame}
\end{mdframed}
\end{figure}


\begin{minted}[gobble=2, samepage=true]{haskell}
  -- This function must be called first thing in the handler. If
  -- something is pushed on top of the stack this will not work any more.
  recoverExecutionStack :: IO (Maybe ExecutionStack)
\end{minted}

This approach will not break backwards compatibility since it does not
change any function in Haskell land. This time \texttt{catchWithStack}
is defined in terms of \texttt{catch} and not the other way around.
But one of the best benefits with this approach is that it introduces a
nice way to implement rethrowing of stack traces.



\subsection{Rethrowing the stack} \label{sec:rethrowing_the_stack}

When throwing an exception for the first time we reify the stack
at the crash site. After reification the exception will be passed to a handler.
We can categorize the resulting effects of running the handler, either:

\begin{itemize}
  \item
    The handler can resolve the exception. For example it can print an
    error message.

  \item
    The handler can declare itself incapable of handling the exception,
    the exception must then be passed to the next handler on the stack.
    We say that the handler \emph{rethrows} the exception. When
    rethrowing we always want the next handler to get the original stack
    trace.

  \item
    The handler itself may crash and generate a completely new exception
    on its own, we say that the handler is \emph{throwing anew}. When
    throwing anew we always want the next handler to get a new stack
    trace.

\end{itemize}

These scenarios do not directly map to an obvious Haskell
interface. Lets consider the programming language Java. Java is a
language that has stack traces and exceptions. In Java, the stack traces
are stored \emph{inside} the exception. To do a rethrow you must throw
the exception value that you caught. If you create a new exception (even
if it is of the same type) a new stack trace will be reified from inside
the handler. Whether if you throw from inside the code of the
handler\footnote{in Java we say that the \texttt{catch}-block is the handler.}
or not does not matter in Java. The way a language defines rethrowing can be summarized
in a table, for Java it would look like be like table TODO. The
stated behavior of Java is based on the experiments in \cite{github_gist_in_out_java}.

When designing any programming language, we will obviously be steered by
what is technically possible. When we tried to put the stack trace value
inside the \texttt{SomeException} type, we realized that the
hierarchical exception system from \cite{marlow2006extensible} is
inferior to actual class hierarchies and ``real'' downcasting that exists in the
object oriented programming language Java. Due to the technical reasons
we can not conveniently store the stack trace in the
\texttt{SomeException} value, so the semantics of throwing in Haskell
can not be identical to Java. Instead we propose that Haskell have the
semantics shown in table TODO, so that we count a throw as a rethrow if
it is within the handler.

\subsubsection{Snatching the trace in the recovery frame}

Now we can contemplate over how to implement rethrowing to follow the
specification in table TODO. The last subsection
mentioned a proposal for \texttt{catchWithStack} where
\texttt{raise\#} pushed a recovery frame before jumping to the handler.
We will now look at another use of this recovery frame: Say that we are
inside a handler, then a recovery frame must be somewhere on the
execution stack. If the handler now does a rethrow, we do not need to pass
the stack trace to the throw function, because the handler-search in
\texttt{raise\#} will walk the stack downwards anyway, when doing that
it can look for the recovery frame and snatch the stack trace stored
within it.

One serious issue is that sometimes a function might intend to rethrow but
do the throwing outside the handler. Consider the
implementation of \texttt{tryJust} from
% TODO(http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Exception-Base.html#tryJust)
reproduced in figure TODO. The implementation of \texttt{tryJust} would
not do a rethrow if Haskell had the rethrow semantics shown in table
TODO(haskell-table) and it is obvious that \texttt{tryJust} should be rethrowing.

There is another problem with using the semantics that throwing in
handlers mean rethrowing. Imagine a long-running handler, the handler
could be calling a separate function that throws on its own, both
rethrowing and throwing anew are likely intents here. What can we
do about this? It would be disastrous if the
user would get an incorrect stack trace! Of course, we will provide
throw functions where a programmer can explicitly say if we throw anew
or if it should look for a recovery frame. But there will still be code
using \texttt{throw} and for those cases the stack traces might be
confusing. One comfort will be that long running handlers that do
install their own catch handler will not be problematic. If a handler install its
own catch frame, the handler will not get the old stack trace
since it lies below the inner catch frame on the stack.
Whether if long-running handlers are common have not been investigated
in this thesis.

Long running handlers also have another issue, the
recovery frame will point to a stack trace value, which means that it
will not get garbage collected until the recovery frame is
popped. For some of the implementations suggested in section
\ref{sec:lazy_reification}, the stack trace value can keep ridiculous
amounts of memory from being garbage collected. The stack trace value
implementation of stack freezing from subsection
\ref{sec:stack_freezing} keeps the whole execution stack at the crash
site alive.

These two issues with long-running handlers can be fixed by having a
way to remove the pushed recovery frame. It must be called immediately
in the handler (just as with \texttt{recoverExecutionStack}):

\begin{minted}[gobble=2, samepage=true]{haskell}
  -- This function must be called first thing in the handler. 
  -- It will remove the recovery frame. Returns true iff successful.
  removeRecoveryFrame :: IO Bool
\end{minted}


Asynchronous, bleh: https://app.asana.com/0/7514515131829/8716532667278
