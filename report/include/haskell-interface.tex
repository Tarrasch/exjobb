\chapter{A Haskell Interface}

Our goal is for Haskell to "have stack traces". This could just mean
that the language prints a stack trace when the program crashes. However
it would be more powerful if the programmer has some control of this.
For example the programmer might want to print the stack trace at
will and not only on a crash. Or the programmer might want to check
if the function \texttt{foo} is on the stack or not. For this to be
possible, some interface has to exist in Haskell-land. One contribution
of this thesis is an Haskell API to the execution stack, section
\ref{sec:user-invoked_reification} explains the design choices when
creating that interface. It would also be great if stack traces got
integrated into the exception mechanism, since once an exception has
occurred, it is to late to get the original stack trace. Another topic
is what rethrowing means, this will be discussed in section 6.3 (TODO).
Section 6.2 (TODO) covers the preliminaries needed to under section 6.3.


% So far we've been
% very vague in our goal. We \emph{could} ask ourselves: Do we want a
% full-blown Haskell API or just to be able to print the stack trace on
% crashes? % TODO: Crash 채r fel ord. Typ hellre n책got med "uncaught exception"
% But it turns out that just phrasing this question is hard.
% It might sound reasonable to say that the most rudimentary feature
% would be that whenever the program crashes, a stack trace should be
% printed. Features like Haskell-land access to the stack would then
% be an extension. But this doesn't make sense from an implementation
% perspective, it is much easier to write a Haskell-wrapper for examining
% the current execution stack than doing an efficient reification at the
% crash site, recall how the whole of section \ref{sec:lazy_reification}
% was dedicated to this. Regardless of a Haskell wrapper being technically
% easy to do,
% the troubles of making it user-friendly are 
% raised in section 6.1 TODO. In section
% 6.2 TODO we look at how the exception system in Haskell is now and
% in section 6.3 TODO we look at ways to fit in a stack value into the
% exception system without affecting existing code too much and still
% being convenient to use.

% Alternativt s책 mergar jag dem tv책 sista sektionerna! TODO ?

\section{User-invoked reification} \label{sec:user-invoked_reification}

The stack traces shown in section \ref{sec:frames_of_interest} look
something like this:

\begin{minted}[gobble=2]{text}
  3: showSignedInt
  4: print
  5: writeBlocks
\end{minted}

We basically have assumed that the DWARF debug data gives us a simple
mapping from instruction pointer to function names. We could model
this in Haskell:

\begin{minted}[gobble=2]{haskell}
  import Foreign.Ptr (Ptr)

  data Instruction -- Empty data declaration (for type safety)
  type FunctionName = String

  lookupWithDwarf :: Ptr Instruction -> IO FunctionName
\end{minted}

But we actually get much more information than just the function name
from the DWARF info. We also know in which file it was defined and more
exactly where in the function. A stack trace including all this
information could look like this:

\begin{minted}[gobble=2]{text}
  3: showSignedInt (at libraries/base/GHC/Show.lhs:432:1-434:56)
  4: print (at libraries/base/System/IO.hs:281:29-281:37)
  5: writeBlocks (at libraries/base/GHC/IO/Handle/Text.hs:584:4-609:31)
\end{minted}

We have created a Haskell data type to encapsulate one frame like shown
above. We call the data type a \texttt{LocationInfo} and its definition
is in figure \ref{fig:location_info}.

\begin{figure}
\begin{mdframed}
  \begin{minted}[gobble=4]{haskell}
    -- | Location in source code.
    data LocationInfo = LocationInfo
        { startLine    :: !Word16
        , startCol     :: !Word16
        , endLine      :: !Word16
        , endCol       :: !Word16
        , fileName     :: !String
        , functionName :: !String
        }
        deriving(Eq)
  \end{minted}
  \caption{The information necessary to display a \emph{row} from the stack
    trace.}
  \label{fig:location_info}
\end{mdframed}
\end{figure}

Yet, there is even more information stored in the DWARF data. For a
given instruction pointer, you would usually associate it to only one
place in the source code, but the situation is not always clear cut due
to code transformations like inlining. Instead we that we have a
mapping from one instruction pointer to \emph{many} source functions.

\begin{minted}[gobble=2]{text}
  3: showSignedInt (at libraries/base/GHC/Show.lhs:432:1-434:56)
  4: print (at libraries/base/System/IO.hs:281:29-281:37)
     putStrLn (at libraries/base/System/IO.hs:267:37-267:38)
     print (at libraries/base/System/IO.hs:281:35-281:36)
  5: writeBlocks (at libraries/base/GHC/IO/Handle/Text.hs:584:4-609:31)
\end{minted}

With the fact that each instruction pointer maps to multiple
source locations, it would make sense for \texttt{lookupWithDwarf} to
return a list of \texttt{LocationInfo}s.
Perhaps the signature should be like the following?

\begin{minted}[gobble=2]{haskell}
  lookupWithDwarf :: Ptr Instruction -> IO [LocationInfo]
\end{minted}

Unfortunately, dwarf information is not always available in the
executable, for example if a Haskell module have been compiled without
the
\texttt{-g} flag. Luckily, symbol table information might still be
packaged inside the binary, which would be able to get out some useful
information.

Note that only \emph{some} modules might have been compiled
with or without \texttt{-g}, so a stack trace could have some stack frames actually
resolved while others just contain information extracted from the symbol
table. Here is an excerpt of a stack trace where the Haskell module \texttt{GHC.Show}
was compiled without the \texttt{-g} flag.

\begin{minted}[gobble=2]{text}
  3: c1lo_entry (using libraries/base/GHC/Show.lhs)
  4: print (at libraries/base/System/IO.hs:281:29-281:37)
     putStrLn (at libraries/base/System/IO.hs:267:37-267:38)
     print (at libraries/base/System/IO.hs:281:35-281:36)
  5: writeBlocks (at libraries/base/GHC/IO/Handle/Text.hs:584:4-609:31)
\end{minted}

While \texttt{c1lo\_entry} is not too useful (but it hints that it
could be a case continuation), the second piece of information is
useful. The file \texttt{Show.lhs} would probably have something to do
with converting a value to a string. Therefore, it would help if the
Haskell value includes this information when it is present. With this
in mind, we decide on the API shown in figure \ref{fig:lookup_with_dwarf}
and \ref{fig:stack_frame}.

\begin{figure}
\begin{mdframed}
  \begin{minted}[gobble=4]{haskell}
    lookupWithDwarf :: Ptr Instruction -> IO StackFrame
  \end{minted}
  \caption{Given an instruction pointer, you get a \texttt{StackFrame} value.}
  \label{fig:lookup_with_dwarf}
\end{mdframed}
\end{figure}

\begin{figure}
\begin{mdframed}
  \begin{minted}[gobble=4]{haskell}
    data StackFrame = StackFrame
        { unitName      :: !String -- From symbol table
        , procedureName :: !String -- Also from symbol table
        , locationInfos :: ![LocationInfo] -- Empty without -g flag to ghc
        }
  \end{minted}
  \caption{The information necessary to display a \emph{frame} from the stack
    trace.}
  \label{fig:stack_frame}
\end{mdframed}
\end{figure}

These decisions are debatable. What happens if there is no symbol
table? What happens if the frame on the execution stack was an update
frame, but we reified the code pointer of its payload (recall section
\ref{sec:update_frames})? Both the signature

\begin{minted}[gobble=2]{haskell}
  lookupWithDwarf :: Ptr Instruction -> IO (Maybe StackFrame)
\end{minted}

and

\begin{minted}[gobble=2]{haskell}
  lookupWithDwarf :: Ptr Instruction -> IO [StackFrame]
\end{minted}

makes sense. But the API should preferably be simple and natural. Most
programmers might be used to a one to one mapping between instruction pointer
and source code. Therefore we choose the signature in figure
\ref{fig:lookup_with_dwarf}. Then, when the programmer looks at what a
\texttt{StackFrame} is, \emph{then} they will be gently introduced to
the fact that a stack frame may contain multiple \texttt{LocationInfo}s.
Contrast this to giving an API based on these observations:

\begin{itemize}
  \item
    One execution stack frame maps to multiple stack frames (like for
    update frames).
  \item
    We "meld" \texttt{StackFrame} and \texttt{LocationInfo}s, basically
    substituting \texttt{StackFrame} with \texttt{[LocationInfo]}.
  \item
    We have function \texttt{getStackFrames} that return a list of the
    frames on the execution stack.
\end{itemize}

Then we would end up with a function like:

\begin{minted}[gobble=2]{haskell}
  getStackFrames :: IO [[[Locationinfo]]]
\end{minted}

Or if we commented the signature:

\begin{minted}[gobble=2]{haskell}
  getStackFrames :: IO
    [ -- The execution stack has multiple frames
     [ -- Each execution stack frame maps to multiple frames
      [ -- An instruction pointer maps to multiple source code locations
      Locationinfo
      ]
     ]
    ]
\end{minted}

No, this is not a user-friendly API. Still, we need to discuss the issue
that the symbol table could have been stripped away and that update
frames can be thought of multiple frames. We solve the first issue by
simply setting the \texttt{String}-fields of a \texttt{StackFrame} to
a descriptive value like \texttt{"<No data>"} if we do not find anything
in the symbol table. In the case of having an
execution stack frame that corresponds to multiple
frames (like for update frames), we pick the most helpful stack frame
(the updatee over the updater).
After all, most reification methods from the previous chapter is only
capable of storing one info pointer per stack frame. But if we were
making all frames accessible from the Haskell API, one idea would be
to squeeze in another field \texttt{next :: Maybe StackFrame} in the
definition of \texttt{StackFrame} from figure \ref{fig:stack_frame}.
Then that particular field's documentation could explain how it works.

Lastly, the API will include some non-controversial functions like
pretty-printing of the execution stack.  Since there is only one natural
implementation for these functions, we do not discuss them further.

\section{Exception system in Haskell}

We say that an \emph{exception system} of a language is how
throwing and catching is done. The exception system for GHC got an
overhaul when version \texttt{6.10.1} was released in November 2008
\cite{haskell_org_release_6.10.1} and the design was introduced in a
paper from 2006 \cite{marlow2006extensible}. In this section we will
look at how this relatively new and current exception system works.

The exception system in Haskell is surprisingly similar to
Java's.  There is a root exception type in Java called \texttt{Exception}
and the Haskell equivalent is called \texttt{SomeException}. One
subclass of exceptions are arithmetic exceptions, Java has
\texttt{ArithmeticException} and Haskell has \texttt{ArithException}.
So Java and Haskell are similar in the sense that they both have a
\emph{extensible and hierarchical} exception system.  Haskell, unlike
Java, do not have anything like the \texttt{throws}
annotation\footnote{Introduced in section
\ref{sec:error_handling_in_haskell}.}
in the type system, but it can be implemented as a library
\cite{github_pepeiborra_cme, hackage_control_monad_exception}.

One way to learn the Haskell exception system is to study the
documentation of the \texttt{Control.Exception} module from the
\texttt{base} library \cite{hackage_base_control_exception}.
That module is quite sizeable, so
we will only study the \texttt{catch} and \texttt{throw} functions since
that is enough background to be able to discuss how stack traces can be added
to the exception system. The documentation contains many functions with various best practices
the programmer should know, \texttt{catch} and
\texttt{throw} is not enough to write good code. With
these warnings being pronounced we go on and with some example
uses of \texttt{catch} and \texttt{throw}. Let's fire up GHCi.

\begin{minted}[gobble=2]{haskell}
  -- We import what we need
  > :set -XScopedTypeVariables
  > import Control.Exception 

  -- It is equivalent to cause the exception and to throw it manually
  > (1 `div` 0)
  *** Exception: divide by zero
  > throw DivideByZero 
  *** Exception: divide by zero

  -- You can catch the exception
  > catch (throw DivideByZero) (\ (e :: SomeException) -> putStrLn "Yaay")
  Yaay

  -- But if the type of the error you are catching is not a superclass
  -- of the exception being thrown, the catch will not be caught
  > catch (throw DivideByZero) (\ (e :: IOException ) -> putStrLn "Yaay")
  *** Exception: divide by zero
\end{minted}

The type signatures of \texttt{catch} and \texttt{throw} can be found in
figure \ref{fig:catch_and_throw}. The signatures are reproduced from the
documentation \cite{hackage_base_control_exception}. The type signature
for both functions are in the form \texttt{:: Exception e => ...}, this
means that \texttt{e} is constrained type. The type variable
\texttt{e} can not be of any type, for example it can not be an \texttt{Int} or a
\texttt{String}, it has to be some sort of an \texttt{Exception}.
\texttt{Exception} is not a type (unlike \texttt{SomeException} and
\texttt{ArithException}), \texttt{Exception} is
\emph{type class}\footnote{The name ``class'' is unfortunate since
it is not at all like classes in object oriented programming, it is
more like interfaces.}! For a particular type to qualify as being an
\texttt{Exception} type, it must adhere to the following interface:

\begin{figure}
\begin{mdframed}
  \begin{minted}[gobble=4]{haskell}
    -- | Throw an exception.  Exceptions may be thrown from purely
    -- functional code, but may only be caught within the 'IO' monad.
    throw :: Exception e => e -> a

    -- | This is the simplest of the exception-catching functions. It
    -- takes a single argument, runs it, and if an exception is raised
    -- the "handler" is executed, with the value of the exception passed
    -- as an argument. Otherwise, the result is returned as normal.
    catch   :: Exception e
            => IO a         -- The computation to run
            -> (e -> IO a)  -- Handler to invoke if an exception is raised
            -> IO a
  \end{minted}
  \caption{The function signatures for \texttt{catch} and
    \texttt{throw} and some excerpts of the documentation.}
  \label{fig:catch_and_throw}
\end{mdframed}
\end{figure}

\begin{itemize}
  \item
    Any value of type \texttt{e} can be converted
    into a value of type \texttt{SomeException}. The programmer has to
    provide the function:
    \mint{haskell}|toException :: e -> SomeException|
  \item
    All \texttt{SomeException} values must have a more concrete type
    underneath\footnote{At least all total and finite
      \texttt{SomeException} values}, the concrete type could for
    example be an \texttt{ArithException}. In general we
    would ask ourselves if a particular \texttt{SomeException} value is
    somewhere down the hierarchy built using a value of type \texttt{e}.
    This is most probably achieved using dynamic types in Haskell.
    The programmer has to provide the function:
    \mint{haskell}|fromException :: SomeException -> Maybe e|
\end{itemize}

So as indicated from the type signatures of \texttt{throw}
and \texttt{catch}, they do use the \texttt{toException} and
\texttt{fromException} functions (otherwise they would not need
the type class constraint). The implementation of \texttt{throw}
uses a primitive that requires a \texttt{SomeException} value as
argument, so \texttt{throw} it has to use \texttt{toException}.
Similarly, catch uses a primitive who expects its handler to receive a
\texttt{SomeException} so that \texttt{fromException} can be used on it
\cite{github_catch_uses_SomeException}.

The implementation of \texttt{toException} and \texttt{fromException}
differs for every type. But the convention is that \texttt{toException}
wraps a bare exception value into wrappers, one wrapper per level of
hierarchy. Similarly \texttt{fromException} removes the layers. For the
hierarchy shown in figure \ref{fig:exception_hierarchy}, the
\texttt{toException} and \texttt{fromException} functions would work
like this:

\begin{figure}
\begin{mdframed}
  \includegraphics[width=5in]{build/fig/exception_hierarchy}
  \caption{One example exception hierarchy.}
  \label{fig:exception_hierarchy}
\end{mdframed}
\end{figure}

\begin{minted}[gobble=2, samepage=true]{haskell}
  > toException MismatchedParentheses
  SomeException
    (SomeCompilerException
      (SomeFrontendException MismatchedParentheses))

  > toException TypeCheckerFailure
  SomeException
    (SomeCompilerException
      (SomeFrontendException TypeCheckerFailure))

  > (fromException :: SomeException -> MismatchedParentheses)
      (toException MismatchedParentheses)
  (Just MismatchedParentheses)

  > (fromException :: SomeException -> TypeCheckerFailure)
      (toException MismatchedParentheses)
  Nothing
\end{minted}

The multiple layer of constructors is added by \texttt{toException}
and \texttt{fromException} checks if its argument was wrapped by the
corresponding \texttt{toException} function.

\section{Adding the trace}

Asynchronous, bleh: https://app.asana.com/0/7514515131829/8716532667278

% http://en.wikibooks.org/wiki/LaTeX/Advanced_Mathematics

blah
