\chapter{Reifying the Stack} \label{chp:reifying_the_stack}

In section \ref{sec:recent_work} we saw Peter Wortmann's prototype for
execution stack based stack traces. It was demonstrated in August
2013 \cite{stack_traces_ticket}. This is a rough sketch of how it is
implemented:

\begin{enumerate}
  \item
    The program starts by installing a catch-all handler. This handler will
    print the stack trace on a crash.
  \item
    Program runs and crashes.
  \item
    The run time system handles the crash by walking through the whole
    execution stack and saving it in a separate array. It then invokes the
    installed handler and passes the array.
\end{enumerate}

To store the essential contents of the stack in a new value,
possibly for later trace-printing, is called \emph{reifying} the
stack. The reification from Peter Wortmann's demonstration is
quite simple, figure \ref{fig:reification} illustrates
this method of reifying the stack.

\begin{figure}
\begin{mdframed}
  \includegraphics[width=5in]{build/fig/reification}
  \caption{An illustration of stack reification, the rightmost box
  is the array allocated to store the result of the reification, the
  diamond arrows show where the content is copied from.}
  \label{fig:reification}
\end{mdframed}
\end{figure}

This chapter will be go into
stack reification in detail. By critically looking
at the prototype, we find room both for improvement and discussion.
In section \ref{sec:frames_of_interest} we see that the stack traces can become more
readable by using the extra information in the payloads of each stack
frame. Section \ref{sec:lazy_reification} deals with the issue of wasting
resources when reifying the stack without ever using it.

\section{Frames of interest} \label{sec:frames_of_interest}

Figure \ref{fig:traces} showed that the stack trace from Peter Wortmann's
demonstration is very far from the ideal stack trace.  Worse, the only
information we have to work with is the execution stack, remember, we maintain no
explicit call stack for performance reasons. Still, the stack can become
clearer by using the payload of the stack frames. For the readers convenience,
we reproduce the stack trace here again as figure \ref{fig:traces_2}.

\begin{figure}
\begin{mdframed}
  \begin{minted}[gobble=4]{text}
     0: stg_bh_upd_frame_ret
     1: stg_bh_upd_frame_ret
     2: stg_bh_upd_frame_ret
     3: showSignedInt
     4: stg_upd_frame_ret
     5: writeBlocks
     6: stg_ap_v_ret
     7: bindIO
     8: bindIO
     9: bindIO
    10: bindIO
    11: stg_catch_frame_ret
  \end{minted}
        \caption{Stack trace. (Same as in figure \ref{fig:trace_goal1})}\label{fig:traces_2}
\end{mdframed}
\end{figure}

The structure of this section is that we will revisit the various
stack frames we looked at in section \ref{sec:members_of_stack}. This
time we will look at how their frame-specific payload can be utilized to make
the stack traces more useful.

\subsection{Update frames} \label{sec:update_frames}

Frame 0,1,2 and 4 from figure \ref{fig:trace_goal1} are all update
frames. Recall that the code for a thunk will push one update
frame. Thunks are common in Haskell and therefore update frames are common
as well. If we were able to print something better
than the cryptic \texttt{stg\_bh\_upd\_frame} and \texttt{stg\_upd\_frame},
many frames in the stack trace would improve.

The actual code of the thunk that pushed the update frame
could be anything. To only see the info pointer of the update frames is hardly helpful.
But we know that the field of the update frame is a reference to the
heap object the update frame is going to update, the \emph{updatee}. The updatee's
info table contains the code that pushed the update frame.
This is really good, because we can copy that info pointer to our array instead,
as illustrated in figure \ref{fig:reify_update_frame}.
Unfortunately this trick only works in some cases and it will depend on the kind of
update frame we have on the stack. There are three different kinds of
update frames \cite{github_updates_cmm}.

\begin{figure}
\begin{mdframed}
  \includegraphics[width=5in]{build/fig/reify_update_frame}
  \caption{An improved way of reifying update frames. The old method is
  showed in the dashed line.}
  \label{fig:reify_update_frame}
\end{mdframed}
\end{figure}

\begin{itemize}
  \item
    \texttt{stg\_bh\_upd\_frame} is the update frame used for global
      thunks. Global thunks are better known as CAFs.
  \item
    \texttt{stg\_upd\_frame} is the update frame used for local
  thunks.
  \item
     \texttt{stg\_marked\_upd\_frame} is created
  by overwriting one of the other two kinds of frames, it
  happens during garbage collection and this phase is named
  \emph{blackholing}. Blackholing converts any update frame to a
  marked update frame \cite{github_overwrite_update_frame} and
  overwrites the updatee's info pointer to point to a "black hole"
  \cite{github_overwrite_blackhole}.
\end{itemize}

Blackholing have become a quite complicated part of the run-time system,
having multiple purposes % TODO: sources?
and is implemented with low-level tricks like pointer tagging. But the
traditional black hole as described in \cite{jones1992tail} is having
clear purposes, blackholing fixes a class of space leaks and it detects
some cases of nontermination. In concurrent Haskell, blackholing have
synchronization purposes that increases sharing (avoids re-computation). Blackholing
is illustrated in figure \ref{fig:thunks_and_blackholes}.

\begin{figure}
\begin{mdframed}
  \begin{subfigure}[t]{0.5\textwidth}
    \includegraphics[width=2.8in]{build/fig/thunk}
    \caption{A thunk}
  \end{subfigure}
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
          %(or a blank line to force the subfigure onto a new line)
  \begin{subfigure}[t]{0.5\textwidth}
    \includegraphics[width=2.8in]{build/fig/blackhole}
    \caption{A blackhole}
  \end{subfigure}
  \caption{A thunk and a blackhole. Traditionally the first thing the
  thunk does is to blackhole itself % TODO source?
  . GHC will not do this however, as it would be wasteful for small
  computations. GHC converts thunks to blackholes during its blackholing
  phase of garbage collection.
}\label{fig:thunks_and_blackholes}
\end{mdframed}
\end{figure}


Unfortunately, only the updatee of local thunks point
at interesting code and not a black hole. The marked update frame
always gets its updatee's info pointer overwritten to a black
hole \cite{github_overwrite_blackhole} and the update frame
for global thunks' updatee point at a black hole to begin with
\cite{github_set_hdr_caf_blackhole}.

\subsubsection{Retaining code reference on blackholing}

The bad effect of blackholing from a stack trace perspective is
that thunks lose the reference to the code that pushed the update frame (recall figure \ref{fig:reify_update_frame} and figure \ref{fig:thunks_and_blackholes}). So instead
of being able to print something useful, like  \texttt{... 4: print ...},
we have to print \texttt{... 4: stg\_upd\_frame\_ret ...}.

Unfortunately, blackholing is not optional
\cite{github_blackholing_not_optional}. It is however possible to
retain the reference by just adding a field for all thunks and
copying the reference there. The extended field is shown in figure
\ref{fig:different_layout}.

\begin{figure}
\begin{mdframed}
  \begin{subfigure}[t]{1\textwidth}
    \includegraphics[width=5.5in]{build/fig/old_thunk}
    \caption{The current layout}
  \end{subfigure}
  \vskip2em
  \begin{subfigure}[t]{1\textwidth}
    \includegraphics[width=5.5in]{build/fig/new_thunk}
    \caption{A layout that has a copy of the original info
pointer, since the first info pointer will be overwritten during
blackholing. }
  \end{subfigure}
  \caption{Two different layout for thunks.}\label{fig:different_layout}
\end{mdframed}
\end{figure}

The extra field has a runtime cost of course. The number of thunks
ever created during the lifetime of a Haskell program has no upper bound. However,
there is only a constant number of global thunks, which means that the
performance cost would be insignificant if we only applied the idea from
figure \ref{fig:different_layout} to global thunks. When
only changing the global thunks, we are able to identify
the \texttt{stg\_bh\_upd\_frame\_ret} frames but not the
\texttt{stg\_marked\_upd\_frame} frames. For example, the
segment

\begin{minted}[gobble=4]{text}
     0: stg_bh_upd_frame_ret
     1: stg_bh_upd_frame_ret
     2: stg_bh_upd_frame_ret
     ...
\end{minted}

could instead be

\begin{minted}[gobble=4]{text}
     0: divZeroError
     1: crashSelf
     2: c
     ...
\end{minted}

by utilizing the new payload. The second stack trace if of course
\emph{much} more useful than the first stack trace. Unfortunately,
to only add the field for global thunks will only be useful for a
short time of the life of the thunk, since blackholing is happening
intermittently. If instead all thunks had the extra field, the blackhole
thunks would also retain the useful reference. Luckily tough, if a
global thunk is containing code that crashes, it is probable that its
update frame will be left intact if it crashes early. In
fact, we should consider ourselves extra lucky, since thunks
memorize themselves. If there were no memoization,
there would be no thunk or no update frames, instead there would be
regular tail calls and the first three frames would not even be on the stack.

\subsection{Artificial frames}

Artificial frames are stack frames whose only purpose is to improve
the stack trace. The intended use case is for programmers that have
got a reproducible bug and a stack trace without enough information.
This should be a common situation, because stack traces derived from the
execution stack often lack frames due to tail calls. A versatile
programmer might switch to one of the many other stack trace
implementations from section \ref{sec:overhead_full}.
But in practice that is usually an overwhelming task
due to technical difficulties like compiler flags and missing libraries. Instead we present
the programmers with an inbuilt primitive to force a stack frame.
When a stack is later reified, these artificial frames would work as
checkpoints and be printed.

The frames are implemented by ... (TODO (Arash): This is unfinished
work, I'm not sure how to implement this.)

\subsection{The other frames}

Some of the stack frames don't need any analysis because their info
pointer is what we want to print, other frames seem hopeless and are not
investigated in depth. In this subsection we will give a brief mention
of the frames that we have not analyzed in depth.

For \emph{case continuations}, the info pointer is pointing to code
generated from Haskell, so we consider case continuations as a
trivial frame. When having an stack frame for a \emph{Call continuations}, we've already
jumped to the interesting code and just left a trace of leftover arguments.
There is nothing to do for call continuations since the leftover arguments
say nothing about the over-applied function itself.
\emph{Catch frames} will hold a reference to the handler, but it is
not what is currently evaluating. The good news is that just seeing
any catch frame is helpful, with some context the programmer might be
able to determine which \texttt{catch} in the source code pushed the
catch frame.

\section{Efficient reification} \label{sec:lazy_reification}

The reification done when executing the program from figure
\ref{fig:sample_program} need to happen at the time of the crash and
not in the handler. When control has been passed to the handler the
execution stack has been unrolled already, so the stack is inaccessible
and maybe even overwritten. At the same time, there is a cost associated
with reifying the stack and the cost is growing linearly with the size
of the execution stack. So when we \emph{know} that we're going to print
out the stack, it is acceptable to have the additional linear cost of
reifying the stack, but we shouldn't tolerate the cost when we are not
using the reified stack value. One consequence of always reifying the
stack is that functions that use \texttt{throw} for control flow will
become slower depending on how big the stack is when they're called.
To have the time complexity of a total Haskell function depending on
the state of the underlying runtime system is not acceptable for a mature
compiler like GHC, so in this section we will look for alternative solutions
to unconditional and strict stack reification.

The two natural solutions are to either reify the stack \emph{conditionally} or
to reify it \emph{lazily}. When reifying the stack conditionally, we only reify the stack
when we know for sure that we are going to print the stack. Subsection
\ref{reify_static_analysis} looks at solutions in this category.
The second approach would be to let the stack value be lazily evaluated. If creating the thunk for
the execution stack value could be done in constant time, we have a
satisfactory solution. Subsection \ref{sec:stack_freezing}
and \ref{sec:chunked_reifying} are implementation ideas for lazy stack values.
But first we take a look at a simple and
unsophisticated solution in subsection \ref{sec:constant_frames}.

\subsection{Reifying a constant number of frames} \label{sec:constant_frames}

A very simple solution would be to just reify a constant number of
frames. The time complexity for any reification would then be constant.
The exact number of frames could be specified through a run-time parameter
or from Haskell-land. There is also a few other benefits with this
approach, for one there would be no user-interface issues with too
long stack traces being printed to the screen, second, as we saw from subsection
\ref{sec:update_frames}, the top of the stack is less likely to have
been blackholed. The drawback is that the stack trace could
be too truncated to be useful.

\subsection{Static analysis} \label{reify_static_analysis}

By analyzing Haskell source code at compile time we can get
information that could help decide whether we should reify the stack or
not. For instance, when we generate the code for the \texttt{throw}
primitive operation, we could choose at compile time if a stack should be reified or
not at this particular usage of \texttt{throw}. Another idea is to do
static analysis on the uses of the \texttt{catch} primitive, one could mark
the catch frames that are using the stack value or not and choose at
run-time to reify the stack value only if the catch frame needs it.

To do static analysis on the uses of \texttt{catch} sounds promising, it has no runtime cost
and sounds easy to implement, but there is a problem. When the execution
stack contains a series of catch statements. If the topmost catch frame
indicates that it doesn't need the stack it will not be able to rethrow
the stack trace to the second catch frame which might need it. Section
TODO from the next chapter will discuss semantics of rethrowing in
detail.

\subsection{Stack freezing} \label{sec:stack_freezing}

One issue with lazy reification is that the stack is a mutable data
structure, so it is not enough to have a reference to the
topmost chunk. The issue of mutability goes away if we make the stack structure
immutable when reifying, we call that \emph{stack freezing}. To freeze the whole stack
would mean to freeze each individual stack chunk. A frozen chunk's
content should be regarded as read-only and the reference to the top
of the stack should not change either. It turns out that thanks to
already existing machinery, stack freezing should be comparably easy to
implement.

Freezing a particular chunk (a \texttt{StgStack} value) would be
trivial by just setting the chunk's \texttt{stack\_size} to be zero
and saving the \texttt{sp}-value to a another field. By setting
the \texttt{stack\_size} to zero, the overflow check described in
section \ref{sec:structure_of_stack} would automatically kick in as a
copy-on-write mechanism. Since we saved the \texttt{sp} value at the time of the reification,
the \texttt{sp} value can change, which means that the stack chunk
can still safely shrink. The stack value itself would be a value with
a reference to the stack chunk that was current at the time of the
exception, as seen in figure \ref{fig:freezing}.

\begin{figure}
\begin{mdframed}
  \includegraphics[width=5.5in]{build/fig/freezing}
  \caption{Illustration of stack freezing. The frames with \texttt{size = 0}
    are the frames that have been frozen by the run time system when a crash
    was detected.}
  \label{fig:freezing}
\end{mdframed}
\end{figure}

So far this solution is linear, since freezing the whole stack would mean
to traverse through each chunk and freezing them. The number of chunks is
linear in the size of the stack. Luckily, we can get away with freezing
the whole stack by only freezing the chunk where the handler lies.
Because when we get an underflow, control is passed to the RTS
\cite{github_underflow_frame}. From the RTS code we could freeze
the next chunk of the underflow frame, which can be thought of as freezing lazily.

There are multiple drawbacks of freezing the stack. When doing a garbage
collection, a stack value has a reference to the old stack and it would
be wasteful to retain the payloads and all their references if the
eventual printed stack trace is only based on the info pointers. Another
drawback is that it is not clear when (if ever) to \emph{thaw} the
stack. Thawing would be the process of undoing the freezing of the
stack. Freezing the stack and the chunk is very cheap, but a frozen chunk
will cause overflows on every push. Thawing can be done in
constant time by just restoring the \texttt{stack\_size} of the current
stack chunk. Thawing would ideally happen when the last stack value
become unreachable from Haskell code, but it is not obvious how this
would be implemented and if the RTS has support for this.

The overall advantage of stack freezing is that we would never actually
need to create another array, so then all payloads are still accessible.
If the payloads are available from the stack value in the handler,
the optimizations from section \ref{sec:frames_of_interest} could be
configurable from code in Haskell-land.

\subsection{Chunked reifying} \label{sec:chunked_reifying}

Chunked reifying of the stack is another idea about doing the stack
reification lazily. In chunked reification we do not freeze the stack, instead, we observe
that the stack is \emph{almost} immutable already! The stack can only
modify itself frame by frame unlike an array which can access any
element. This is a powerful property since this means that the stack is
almost immutable. The idea of chunked reification is that when the stack
pointer moves down towards the bottom of the stack, we start
copying over frames before they get overwritten.

Luckily, the execution stack as implemented in GHC is already chunked
and we could decide to reify the next chunk on each underflow. Like with
the approach of stack freezing, it would help performance to do something similar
to thawing the stack when stack values become inaccessible. While
chunked reification doesn't freeze the stack it must be able to tell
stack parents that they don't need to reify on underflows when no stack
value is alive anymore.
