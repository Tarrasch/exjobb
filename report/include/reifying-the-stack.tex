\chapter{Reifying the Stack}

In the previous chapter we looked at how the stack works, in its
last section we saw the process of reifying the stack as it was
implemented in Peter Wortmann's demonstration in August 2013
\cite{stack_traces_ticket}. This chapter will be dedicated to examine
the when and how of stack reification in detail. By looking critically
of the prototype, we find room both for improvement and discussion.

In section 5.1 TODO we see that the stack traces can become more
readable by using the extra information in the payloads of each stack
frame. Section 5.2 TODO deals with the issue of wasting
resources when reifying the stack without ever using it.

\section{Frames of interest}

Figure \ref{fig:traces} showed that the stack trace from Peter Wortmann's
demonstration is very far from the ideal stack trace.  Worse, the only
information we have to work with is the execution stack since we maintain no
explicit call stack for performance reasons. Yet, the stack can become
clearer by using the payload of the stack frames.

We reproduce the stack trace here again:

\begin{minted}[gobble=4]{text}
     0: stg_bh_upd_frame_ret
     1: stg_bh_upd_frame_ret
     2: stg_bh_upd_frame_ret
     3: showSignedInt
     4: stg_upd_frame_ret
     5: writeBlocks
     6: stg_ap_v_ret
     7: bindIO
     8: bindIO
     9: bindIO
    10: bindIO
    11: stg_catch_frame_ret
\end{minted}


\subsection{Update frames}

The actual code that is executing under the wing of an update frame
could be anything, to see update frames on the stack is hardly helpful.
But we know that the field of the update frame is a reference to the
heap object the update frame is going to update, the \emph{updatee}. The updatee's
info table contains the code that we're currently running, so we instead
copy that data into our array. See figure \ref{fig:reify_update_frame}.

\begin{figure}
\begin{mdframed}
  \includegraphics[width=5in]{build/fig/reify_update_frame}
  \caption{An improved way of reifying update frames. The old method is
  showed in the dashed line.}
  \label{fig:reify_update_frame}
\end{mdframed}
\end{figure}

Frame 0,1,2 and 4 are all update frames. There is exactly three kinds
of update frames \cite{github_updates_cmm}:

\begin{itemize}
  \item
    \texttt{stg\_bh\_upd\_frame} is the update frame used for global
      thunks. Global thunks are better known as CAFs.
  \item
    \texttt{stg\_upd\_frame} is the update frame used for local
  thunks. \item \texttt{stg\_marked\_upd\_frame} is created
  by overwriting one of the other two kinds of frames, it
  happens during garbage collection and this phase is named
  \emph{blackholing}. Blackholing converts any update frame to a
  marked update frame \cite{github_overwrite_update_frame} and
  overwrites the updatee's info pointer to point to a "black hole"
  \cite{github_overwrite_blackhole}.
\end{itemize}

Unfortunately, only the \texttt{stg\_upd\_frame}'s updatee point
at interesting code and not a black hole. The marked update frame
always gets its updatee's info pointer overwritten to a black
hole \cite{github_overwrite_blackhole} and the update frame
for global thunks' updatee point at a black hole to begin with
\cite{github_set_hdr_caf_blackhole}.

\section{Lazy reification}

The reification done when executing the program from figure
\ref{fig:sample_program} need to happen at the time of the crash and
not in the handler. When control have been passed to the handler the
execution stack have been unrolled already, so the stack is unaccessible
and maybe even overwritten. At the same time, there is a cost associated
with reifying the stack and the cost is growing linearly with the size
of the execution stack. So when we \emph{know} that we're going to print
out the stack, it is acceptable to have the additional linear cost of
reifying the stack, but we shouldn't tolerate the cost when we are not
using the reified stack value. One consequence of always reifying the
stack is that functions that use \texttt{throw} for control flow will
become slower depending on how big the stack is when they're called.

The discussion in the previous paragraph have one natural solution, to
let the stack value to be \emph{lazily evaluated}. Then we would only
reify the execution stack when we need to. If creating the thunk for
the execution stack value could be done in constant time, we obtain the
ideal solution per the previous discussion. In this section we look at
various solutions to solve the problem that functions run-time depending
on the size of the stack. Some solutions will not need to implement
lazy stack values.
