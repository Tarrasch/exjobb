\chapter{Background}

% TODO: text här? Upplägg?

\section{Stack traces}

When a computer program crashes, the runtime of some programming languages
gives some context to where in the code the program crashed.
Typically, a \emph{stack trace} is printed. A stack trace is the listing
of the functions that have called each other and have not exited yet, so
they have all been part of the crash. The first function in the stack
trace is always the program entry point, the last function is where the
crash actually occurred.

The Rosetta Code wiki contains a code sample in Ruby illustrating a stack
trace \cite{rosetta_stone_st}, reproduced here in figure
\ref{fig:ruby_stack_trace}. As the figure shows, some languages can print stack
traces at any time, not only after crashes. Stack traces can not be
implemented as a regular user-level library, stack traces will need
to look at the internal state of the run time system or interpreter.
In the case of ruby, they have the magical primitive \texttt{caller} which
retrieves the call chain. It would not be possible for a user
to implement \texttt{caller} in pure ruby. To implement stack traces
in Haskell is no exception, the implementation we present in this work
will need to look at the internal state of the runtime system and has to
target a specific Haskell compiler. The compiler we target is GHC.

\begin{figure}
\begin{mdframed}
  \begin{subfigure}[t]{0.5\textwidth}
      \begin{minted}{ruby}
def outer(a,b,c)
  middle a+b, b+c
end

def middle(d,e)
  inner d+e
end

def inner(f)
  puts caller(0)
  puts "my arg is #{f}"
end

outer 2,3,5
       \end{minted}
    \caption{Ruby code printing a stack trace}
    ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
    %(or a blank line to force the subfigure onto a new line)
  \end{subfigure}
        \begin{subfigure}[t]{0.5\textwidth}
          \begin{verbatim}
$ ruby stacktrace.rb
stacktrace.rb:10:in `inner'
stacktrace.rb:6:in `middle'
stacktrace.rb:2:in `outer'
stacktrace.rb:14
my arg is 13
          \end{verbatim}
          \caption{Output of running the ruby program.}
        \end{subfigure}
        \caption{Illustration of a simple stack trace
        }\label{fig:ruby_stack_trace}
\end{mdframed}
\end{figure}

\section{Haskell}

Haskell is a lazy, functional, general-purpose programming language \cite{haskell_report2010}.
Haskell first appeared in 1990 \cite{HistoryOfHaskell2007}  and have since
released the major standards Haskell 98 and Haskell 2010
\cite{haskell_report2010}.

\begin{figure}
\begin{mdframed}
  \begin{minted}{haskell}
main = print (fibonacci 10)

fibonacci :: Int -> Int
fibonacci 1 = 0
fibonacci 2 = 1
fibonacci x = fibonacci (x - 1) + fibonacci (x - 2)
  \end{minted}
  \caption{A simple Haskell program}
  \label{fig:simple_program}
\end{mdframed}
\end{figure}

Figure \ref{fig:simple_program} shows a simple program in Haskell.
Two functions are defined in this program, \texttt{main} and
\texttt{fibonacci}.  The explicit type signature for the function
\texttt{fibonacci} means that it takes an int and returns an int. If a type
signature is omitted, like for \texttt{main}, Haskell will infer it automatically.

\subsection{Error handling in Haskell}

In order for stack traces to be relevant for a programming language, programs
must have the notion of \emph{crashing}. Intuitively, crashing causes sudden
stops in execution, either by the operating system or by the language's own
exception handling. Program crashes can be disastrous, since they will also
terminate processes that are supposed to be long-running. Hence there are
language constructs to eliminate some causes of program crashes.
For instance,
evaluating a well-typed expression in Haskell can not segfault \cite{FindingTheNeedle2009}.

In Haskell, there's a notion of a function being \emph{total}. Meaning
that a function will terminate and not return any error. Therefore,
such a function can not crash. Unfortunately, as of the famous halting
problem it's not possible to decide if a function will terminate or not.
That implies that you can't in general
verify that a function is total. \cite[p.380]{Hopcroft:2000}
The good news, though, is that whenever we
explicitly \emph{choose} to crash, we can systematically avoid it. This is not
only true in the language Haskell, Java implements this through the
\texttt{throws} keyword \cite{oracle_java_doc_method_throws}. 
To annotate the function signature with \texttt{throws ArithmeticException}
would mean that the function may throw an \texttt{ArithmeticException}.
Figure \ref{fig:total_java} shows a Java integer division function that's
total.

\begin{figure}
\begin{mdframed}
  \begin{subfigure}[t]{1\textwidth}
      \begin{minted}{java}
int integerDivision (int nom, int den) throws ArithmeticException {
  if (den == 0) {
    throw ArithmeticException("Division by zero");
  }
  else {
    return nom / den;
  }
}
       \end{minted}
    \caption{A total function in Java}
    \label{fig:total_java}
  \end{subfigure}
        \vskip2em
        \begin{subfigure}[t]{1\textwidth}
          \begin{minted}{haskell}
integerDivision :: Int -> Int -> Maybe Int
integerDivision n 0 = Nothing
integerdivision n d = Just (n `div` d)
          \end{minted}
          \caption{A total function in Haskell}
          \label{fig:total_haskell}
        \end{subfigure}
        \caption{Two total functions
        }\label{fig:total_functions}
\end{mdframed}
\end{figure}


In Haskell, the convention is instead to return the special value
\texttt{Nothing}. To do this in Haskell, the \emph{Maybe} wrapper must be
put in the function signature. See figure \ref{fig:total_haskell}.

The two functions in figure \ref{fig:total_functions} will not crash when dividing
by zero, rather, they gracefully return a value of either the division or a
value representing failure. But there's a drawback, both these functions are
cumbersome to use. In Java the programmer needs to explicitly catch the
Exception combining the \texttt{try} and \texttt{catch} constructs
\cite{oracle_java_doc_compile_time_checking_of_exceptions, oracle_java_doc_catch}.
In Haskell, an additional layer of pattern
matching is required. Due to this inconvenience, both languages allow
for carrying out integer division without forcing the caller to do any
error handling. Figure \ref{fig:partial_functions} shows two partial
functions. Partial functions are controversial in Java
\cite{oracle_java_doc_controversy} and discouraged when unnecessary in
Haskell \cite{haskellwiki_avoiding_partial_functions}

\begin{figure}
\begin{mdframed}
  \begin{subfigure}[t]{1\textwidth}
      \begin{minted}{java}
int integerDivisionUnsafe (int nom, int den) {
  return nom / den;
}
      \end{minted}
    \caption{A partial function in Java}
    \label{fig:partial_java}
  \end{subfigure}
        \vskip2em
        \begin{subfigure}[t]{1\textwidth}
          \begin{minted}{haskell}
integerDivisionUnsafe :: Int -> Int -> Int
integerDivisionUnsafe n 0 = error "Division by zero"
integerDivisionUnsafe n d = n `div` d
          \end{minted}
          \caption{A partial function in Haskell}
          \label{fig:partial_haskell}
        \end{subfigure}
        \caption{Two partial functions
        }\label{fig:partial_functions}
\end{mdframed}
\end{figure}

For the first time we now see the \texttt{error} function in Haskell (figure \ref{fig:partial_haskell}).  \texttt{error} is a
special built-in function that terminates execution and outputs the provided
message. While it's not entirely accurate, we could think of \texttt{error}
being the only gateway to crashing a Haskell program. That means that all the
typical dangerous operations like integer division by zero or indexing outside
an array would just invoke the \texttt{error} function. We define ``crashing''
to be whenever \texttt{error} is called.

\section{Glasgow Haskell Compiler}

The Glasgow Haskell Compiler (GHC) is a Haskell2010 compatible compiler.
\cite{ghc_website} With it you can compile Haskell source code to an executable
binary. Here's an invocation of the compiler on the program sample from figure \ref{fig:simple_program}.

\begin{minted}{bash}
  $ ghc --make Fibonacci.hs
  ...
  $ ./a.out
  34
\end{minted}

GHC as of today support many features in addition to the Haskell2010
standard, like parallelism, many optimizations, an LLVM backend, profiling
and more \cite{ghc_website}.

\subsection{The execution stack}

Most programmers have a decent picture of how programming languages
implement functions. Whenever a function is called, its arguments are
pushed on the stack by the caller and the caller jumps to the function's
code. When the function finally exits, it returns to where it was called
from and pops the stack arguments. This was a short reminder of how
the \emph{regular stack} works. Most programming languages use this to
implement functions.

Due to the nature of Haskell, it's not clear if the stack that worked
so naturally for languages like C can be used to implement Haskell.
How does it work with partial applications? How does it work for
laziness? Instead one might look at creating a completely new execution
machine. The \emph{Spineless Tagless G-Machine} (STG) from
\cite{stg_1992} is implemented in GHC \cite{evalapplyjfp06} in the sense
that Haskell is compiled down to the STG language at some point during compilation.
The STG machine has a stack called the \emph{execution stack}. The details
of the execution stack changes as new versions of GHC are released.
In this work we have documented it by examining source code
from the 7.6.2 version of GHC.

\section{From source to machine code}

Typically, compilers take source code and convert it to machine code.
It would be overwhelming to go directly to machine code, instead most
compilers have some intermediate representations (IR) in the pipeline \cite[p.358]{aho2007compilers}.  For GHC, the pipeline is illustrated in
figure \ref{fig:ghc_phases} \cite{terei2009low}.

\begin{figure}
  \centering
  \includegraphics[width=5.5in]{build/fig/phases}
  \caption{The GHC phases of compilation. The LLVM and C-backend are not
shown.}\label{fig:ghc_phases}
\end{figure}

There is one common complex problem that must be solved to enable debugging
tools: The programmer thinks of the program as it's source code and the
semantics of the language. However, the processor only runs machine code.
Unfortunately, there is no way to associate the machine code to the
source code that it originated from. This is a problem for all applications of
debugging, not limited to stack traces. \cite{eager2012introduction} As a consequence, any
compiler that wants to support debugging has to do the truly overwhelming task of threading along
information about the original source code that got compiled into each
intermediate step, this information must also be retained and tranformed
accordingly during all the optimization steps. In fact, this is impossible and
any implementation can only be a best effort implementation, figure
\ref{fig:same_functions} motivates this.

\begin{figure}
\begin{mdframed}
  \begin{minted}{haskell}
kilometerToMeter = (*1000)
kilogramToGram = (*1000)
  \end{minted}
  % TODO: Seems like nobody can understand this maybe add a better picture?
  \caption{Two functions with identical implementations. A smart compiler
    will understand this and only generate code for one of them and
    calls to \texttt{kilometerToMeter} and \texttt{kilogramToGram}
    generates identical code. But this has a serious drawback because a
    stack trace involving one of the two functions can't exist, as
    the two functions are indistinguishable.}
  \label{fig:same_functions}
\end{mdframed}
\end{figure}

Finally, the information  about the source-level functions that the compiler
have held tight throughout the IRs must get packaged into the binary. This
concern arises naturally in the final IR stage.  How does the compiler emit the
debug information? How is it stored in a way so it doesn't get in the way of the
actual code?  A debugging format answers these questions. One such debugging
format is DWARF.

\section{DWARF}

In 1988, DWARF was created hoping to solve a quite general problem. DWARF is
a language agnostic debugging format that is still producing updated revisions.
DWARF 5 is planned to be released in 2014. \cite{eager2012introduction} The DWARF data that is
stored in the binary can be understood by a debugger like \texttt{gdb}. For example,
it could help gdb explain how some data should be displayed, for instance if a
particular byte is a 8-bit number or a character. As will be revealed in
section \ref{sec:recent_work}, this thesis work was made possible thanks
to that DWARF got integrated in GHC.
