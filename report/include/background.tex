\chapter{Background}

% TODO: text här? Upplägg?

\section{Stack traces}

When a computer program crashes, the runtime of some programming languages
gives some context to where in the code the program crashed.
Typically, a \emph{stack trace} is printed. A stack trace is the listing
of the functions that have called each other and have not exited yet, so
they have all been part of the crash. The first function in the stack
trace is always the program entry point, the last function is where the
crash actually occurred.

The Rosetta Code wiki contains a code sample in Ruby illustrating a stack
trace \cite{rosetta_stone_st}, reproduced here in figure
\ref{fig:ruby_stack_trace}. As the figure shows, some languages can print stack
traces at any time, not only after crashes.

\begin{figure}
\begin{mdframed}
  \begin{subfigure}[t]{0.5\textwidth}
      \begin{minted}{ruby}
def outer(a,b,c)
  middle a+b, b+c
end

def middle(d,e)
  inner d+e
end

def inner(f)
  puts caller(0)
  puts "my arg is #{f}"
end

outer 2,3,5
       \end{minted}
    \caption{Ruby code printing a stack trace}
    ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
    %(or a blank line to force the subfigure onto a new line)
  \end{subfigure}
        \begin{subfigure}[t]{0.5\textwidth}
          \begin{verbatim}
$ ruby stacktrace.rb
stacktrace.rb:10:in `inner'
stacktrace.rb:6:in `middle'
stacktrace.rb:2:in `outer'
stacktrace.rb:14
my arg is 13
          \end{verbatim}
          \caption{Output of running the ruby program. We can see that the
            function \texttt{caller} retrieves the complete call chain. It's
            a primitive supported in the language}
        \end{subfigure}
        \caption{Illustration of a simple stack trace
        }\label{fig:ruby_stack_trace}
\end{mdframed}
\end{figure}

\section{Haskell}

Haskell is a lazy, functional, general-purpose programming language.
\cite{haskell_report2010}
It first appeared in 1990 \cite{HistoryOfHaskell2007}  and have since
released the major standards Haskell 98 and Haskell 2010
\cite{haskell_report2010}.

\begin{figure}
\begin{mdframed}
  \begin{minted}{haskell}
main = print (fibonacci 10)

fibonacci :: Int -> Int
fibonacci 1 = 0
fibonacci 2 = 1
fibonacci x = fibonacci (x - 1) + fibonacci (x - 2)
  \end{minted}
  \caption{A simple Haskell program}
  \label{fig:simple_program}
\end{mdframed}
\end{figure}

Figure \ref{fig:simple_program} shows a simple program in Haskell.
Two functions are defined in this program, \texttt{main} and
\texttt{fibonacci}.  The explicit type signature for the function
\texttt{fibonacci} means that it takes an int and returns an int. If a type
signature is omitted, like for \texttt{main}, Haskell will infer it automatically.

\subsection{Error handling in Haskell}

In order for stack traces to be relevant for a programming language, programs
must have the notion of \emph{crashing}. Intuitively, crashing causes sudden
stops in execution, either by the operating system or by the language's own
exception handling. Program crashes can be disastrous, since they will also
terminate processes that are supposed to be long-running. Hence there are
language constructs to eliminate some causes of program crashes.
For instance,
in well-typed Haskell programs, there are no segfaults \cite{FindingTheNeedle2009}.
% TODO: (behövs? källa?)   or any other time where the operating system
% directly intervenes. (really? source?)

In Haskell, there's a notion of a function being \emph{total}. Meaning
that a function will terminate and not return any error. Therefor,
such a function can not crash. Unfortunately, as of the famous halting
problem it's not possible to decide if a function will terminate or not.
That implies that you can't in general
verify that a function is total. \cite[p.380]{Hopcroft:2000}
The good news, though, is that whenever we
explicitly \emph{choose} to crash, we can systematically avoid it. This is not
only true in the language Haskell, Java implements this through the
\texttt{throws} keyword. \cite{oracle_java_doc_method_throws} Where
function signatures are annotated if they may error.
Figure \ref{fig:total_java} shows a Java integer division function that's
total.

\begin{figure}
\begin{mdframed}
  \begin{subfigure}[t]{1\textwidth}
      \begin{minted}{java}
int integerDivision (int nom, int den) throws ArithmeticException {
  if (den == 0) {
    throw ArithmeticException("Division by zero");
  }
  else {
    return nom / den;
  }
}
       \end{minted}
    \caption{A total function in Java}
    \label{fig:total_java}
  \end{subfigure}
        \vskip2em
        \begin{subfigure}[t]{1\textwidth}
          \begin{minted}{haskell}
integerDivision :: Int -> Int -> Maybe Int
integerDivision n 0 = Nothing
integerdivision n d = Just (n `div` d)
          \end{minted}
          \caption{A total function in Haskell}
          \label{fig:total_haskell}
        \end{subfigure}
        \caption{Two total functions
        }\label{fig:total_functions}
\end{mdframed}
\end{figure}


In Haskell, it's instead convention to simply not return a value when there's
no valid value to return. To do this in Haskell, the \emph{Maybe} wrapper is
used to allow functions to gracefully fail, as illustrated in figure
\ref{fig:total_haskell}.

The two functions in figure \ref{fig:total_functions} will not crash when dividing
by zero, rather, they gracefully return a value of either the division or a
value representing failure. But there's a drawback, both these functions are
cumbersome to use. In Java the programmer needs to explicitly catch the
Exception % TODO (citera?)
combining the \texttt{try} and \texttt{catch} constructs.
\cite{oracle_java_doc_catch} In Haskell, an additional layer of pattern
matching is required. Due to this inconvenience, both languages allow for
carrying out integer division without forcing the caller to do any error
handling. Figure \ref{fig:partial_functions} shows two partial functions.
% TODO fotnot om att det i java kallas RuntimeException när det intebehöver
% fångas?
% Alternativt kan man ju faktiskt ge länken till kontreversin
% http://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html
% om unchecked exceptions. För att visa att det jag pratar om är en riktig
% grej.

\begin{figure}
\begin{mdframed}
  \begin{subfigure}[t]{1\textwidth}
      \begin{minted}{java}
int integerDivisionUnsafe (int nom, int den) {
  return nom / den;
}
      \end{minted}
    \caption{A partial function in Java}
    \label{fig:partial_java}
  \end{subfigure}
        \vskip2em
        \begin{subfigure}[t]{1\textwidth}
          \begin{minted}{haskell}
integerDivisionUnsafe :: Int -> Int -> Int
integerDivisionUnsafe n 0 = error "Division by zero"
integerDivisionUnsafe n d = n `div` d
          \end{minted}
          \caption{A partial function in Haskell}
          \label{fig:partial_haskell}
        \end{subfigure}
        \caption{Two partial functions
        }\label{fig:partial_functions}
\end{mdframed}
\end{figure}

For the first time we now see the \texttt{error} function in Haskell (figure \ref{fig:partial_haskell}).  It's a
special in-built function that terminates execution and outputs the provided
message. While it's not entirely accurate, we could think of \texttt{error}
being the only gateway to crashing a Haskell program. That means that all the
typical dangerous operations like integer division by zero or indexing outside
an array would just invoke the \texttt{error} function. We define ``crashing''
to be whenever \texttt{error} is called.

% (footnote: It's
% rather the evaluation of an expression tree having \texttt{error} as it's top
% expression). % TODO: Behövs inte kanske.

% TODO: (ska man ha en formell Definition 1.1 blah blah här?)

\section{Glasgow Haskell Compiler}

The Glasgow Haskell Compiler (GHC) is a Haskell2010 compatible compiler.
\cite{ghc_website} With it you can compile Haskell source code to an executable
binary. Here's an invocation of the compiler on the program sample from figure \ref{fig:simple_program}.

\begin{minted}{bash}
  $ ghc --make Fibonacci.hs
  ...
  $ ./a.out
  34
\end{minted}

% GHC is the by far most used Haskell compiler (source). It has always (?)
% been in active (?) development since its first release in 199x (source) (Onödigt? Ta
% bort allt till och med hit?). Since then, many notable extensions have been
% added.
GHC as of today support many features in addition to the Haskell2010
standard, like parallelism, many optimizations, an LLVM backend, profiling
and more \cite{ghc_website}. This
work is adding low overhead stack traces to that list.

\subsection{The execution stack}

Most programmers have a decent picture of how programming languages implement
functions. They use the stack pointer register. Whenever a function is called, its
arguments are pushed on the stack by the caller and the caller jumps to the
functions code. When the function finally exits, it returns to where it was
called from. This was a short reminder of how the \emph{regular stack} works.
Most programming languages use this to implement the concept of functions.

Due to the nature of Haskell. It's not clear if the stack that
worked so naturally for languages like C can be used to implement
Haskell. How does it work with partial applications? How does it
work for laziness? Instead one might look at creating a completely
new execution machine not based on a stack. Peyton Jones created the
Spineless Tagless G-Machine (STG) \cite{stg_1992} which GHC implements
\cite{evalapplyjfp06} in the sense that Haskell is compiled down to
STG at some point during compilation. This machine also have a stack
called the \emph{execution stack}. It's similar to stacks in a typical
programming languages.

% TODO Detta nedanför verkar lite Påhittat ...
% One property of this
% stack is that a function written in the original source language (the
% Haskell code) will have its own stack frame on the stack. Again, this is
% not a necessity for a Haskell implementation. But it is the whole basis
% of this thesis. If stack traces are going to be reconstructed by walking
% the stack, a stack must exist! The take away here is that when we're
% talking about walking the stack in this paper, we mean the execution
% stack as described in the STG, not the traditional stack. Therefore my
% work only applies to GHC and not Haskell in general.

% TODO: (bra bild på stacken)

% TODO: Att det är en länkad lista kanske ska komma senare I nästa del? Eller
% ska den komma här? Troligen här va? Typ som i Tereis paper

\section{From source to machine code}

Typically, compilers take source code and convert to machine code. To ease this
task, there usually are some intermediate representations (IR) in the source
code to machine code pipeline.  For GHC, the representations are illustrated in
figure TODO. It's outside the scope of this paper to look at how the IRs
look like. But the general strategy of successively recasting source code to lower and
lower abstractions until it becomes machine code is very relevant to this work
and is not only happening in Haskell compilers. (TODO citera dragon book?) (TODO citera Terei)

There is one common complex problem that must be solved to enable debugging
tools: The programmer thinks of the program as it's source code and the
semantics of the language. However, the processor only runs machine code.
Unfortunately, there is by default no way to associate the machine code to the
source code that it originated from. This is a problem for all applications of
debugging, not limited to stack traces. (Cite: dwarf) As a consequence, any
compiler that wants to support debugging (footnote: without changing
performance) have to do the truly overwhelming task of threading along
information about the original source code that got compiled into each
intermediate step, this information must also be retained and tranformed
accordingly during all the optimization steps. In fact, this is impossible and
any implementation can only be a best effort implementation, figure TODO
motivates this.

Finally, the information  about the source-level functions that the compiler
have held tight throughout the IRs must get packaged into the binary. This
concern arises naturally in the final IR stage.  How does the compiler emit the
debug information? How is it stored in a way so it doesn't get in the way of the
actual code?  A debugging format answers these questions. One such debugging
format is called DWARF.

\section{DWARF}

In 1988, DWARF was created hoping to solve the quite general problem. DWARF is
a language agnostic debugging format that is still producing updated revisions.
DWARF 5 is planned to be released in 2014. (Cite: Dwarf) The DWARF data that is
stored in the binary can the be understood by a debugger like gdb. For example,
it could help gdb explain how some data should be displayed, for instance if a
particular byte is a 8-bit number or a character. As will be revealed in
section \ref{sec:recent_work}, this thesis work was made possible thanks
to that DWARF got integrated in GHC.
